// This file is auto-generated by @hey-api/openapi-ts
import {
  type DefaultError,
  type InfiniteData,
  type UseMutationOptions,
  infiniteQueryOptions,
  queryOptions,
} from '@tanstack/react-query';

import { client as _heyApiClient } from '../client.gen';
import {
  type Options,
  authenticate,
  clearAllMentions,
  clearChatMessage,
  collectionSearch,
  copyManyItems,
  createApp,
  createAppAction,
  createAppData,
  createAppDataFile,
  createAppSetting,
  createAppSettingFile,
  createBookmark,
  createChatMessage,
  createChatbotCompletionPrompt,
  createDocument,
  createEtherpad,
  createFolder,
  createFolderWithThumbnail,
  createInvitation,
  createItem,
  createItemFlag,
  createItemLike,
  createItemMembership,
  createItemWithThumbnail,
  createLink,
  createMembershipRequest,
  createOwnProfile,
  createShortLink,
  createShortcut,
  createTagForItem,
  createVisibility,
  deleteAlias,
  deleteAppData,
  deleteAppSetting,
  deleteBookmark,
  deleteChatMessage,
  deleteCurrentAccount,
  deleteGeolocation,
  deleteInvitation,
  deleteItemLike,
  deleteItemLoginSchema,
  deleteItemMembership,
  deleteItemsByIdThumbnails,
  deleteManyItems,
  deleteMembersMembersByIdDelete,
  deleteMembershipRequest,
  deleteMention,
  deleteTagForItem,
  deleteVisibility,
  downloadAppDataFile,
  downloadAppSettingFile,
  downloadAvatar,
  downloadFile,
  downloadItemThumbnail,
  enroll,
  exportActions,
  exportMemberData,
  exportZip,
  generateAppToken,
  geolocationReverse,
  geolocationSearch,
  getAccessibleItems,
  getAppActionsForApp,
  getAppContext,
  getAppDataForApp,
  getAppList,
  getAppSettingsForApp,
  getChat,
  getChildren,
  getCollectionInformations,
  getCollectionsForMember,
  getCountForTags,
  getCurrentAccount,
  getDescendantItems,
  getEtherpadFromItem,
  getFacetsForName,
  getFeaturedCollections,
  getFlagTypes,
  getGeolocationByItem,
  getInvitationById,
  getInvitationForItem,
  getItem,
  getItemActionsByDay,
  getItemActionsByHour,
  getItemActionsByWeekday,
  getItemLoginSchema,
  getItemLoginSchemaType,
  getItemMembershipsForItem,
  getItemsCollectionsSearchRebuild,
  getItemsH5pAssetsIntegrationHtml,
  getItemsInBox,
  getItemsPublicationByItemIdStatus,
  getLatestItemValidationGroup,
  getLikesForCurrentMember,
  getLikesForItem,
  getLinkMetadata,
  getLogout,
  getMemberProfile,
  getMembersActions,
  getMembersCurrentPasswordStatus,
  getMembershipRequestsByItemId,
  getMostLikedCollections,
  getMostRecentCollections,
  getNextMaintenance,
  getOneMember,
  getOwnBookmark,
  getOwnMembershipRequestByItemId,
  getOwnMentions,
  getOwnMostUsedApps,
  getOwnProfile,
  getOwnRecycledItems,
  getParentItems,
  getShortLinkAvailability,
  getShortLinkRedirection,
  getShortLinksForItem,
  getStatus,
  getStorage,
  getStorageFiles,
  getTagsForItem,
  getUrl,
  getVersion,
  getWs,
  graaspZipExport,
  health,
  importH5P,
  importZip,
  inviteFromCsv,
  inviteFromCsvWithTemplate,
  login,
  loginOrRegisterAsGuest,
  moveManyItems,
  patchChangeEmail,
  patchChatMessage,
  patchMention,
  patchPassword,
  patchPasswordReset,
  postAction,
  postChangeEmail,
  postItemsByIdThumbnails,
  postLoginPassword,
  postMembersAvatar,
  postPassword,
  postPasswordReset,
  publishItem,
  putGeolocation,
  recycleManyItems,
  register,
  reorderItem,
  restoreManyItems,
  sendInvitation,
  unpublishItem,
  updateApp,
  updateAppData,
  updateAppSetting,
  updateCurrentAccount,
  updateDocument,
  updateEtherpad,
  updateFile,
  updateFolder,
  updateInvitation,
  updateItem,
  updateItemLoginSchema,
  updateItemMembership,
  updateLink,
  updateOwnProfile,
  updateShortLink,
  updateShortcut,
  uploadFile,
  validateItem,
} from '../sdk.gen';
import type {
  AuthenticateData,
  ClearAllMentionsData,
  ClearAllMentionsError,
  ClearAllMentionsResponse,
  ClearChatMessageData,
  ClearChatMessageError,
  ClearChatMessageResponse,
  CollectionSearchData,
  CollectionSearchError,
  CollectionSearchResponse,
  CopyManyItemsData,
  CopyManyItemsError,
  CopyManyItemsResponse,
  CreateAppActionData,
  CreateAppActionError,
  CreateAppActionResponse,
  CreateAppData,
  CreateAppDataData,
  CreateAppDataError,
  CreateAppDataFileData,
  CreateAppDataFileError,
  CreateAppDataResponse,
  CreateAppError,
  CreateAppResponse,
  CreateAppSettingData,
  CreateAppSettingError,
  CreateAppSettingFileData,
  CreateAppSettingFileError,
  CreateAppSettingFileResponse,
  CreateAppSettingResponse,
  CreateBookmarkData,
  CreateBookmarkError,
  CreateBookmarkResponse,
  CreateChatMessageData,
  CreateChatMessageError,
  CreateChatMessageResponse,
  CreateChatbotCompletionPromptData,
  CreateChatbotCompletionPromptError,
  CreateChatbotCompletionPromptResponse,
  CreateDocumentData,
  CreateDocumentError,
  CreateDocumentResponse,
  CreateEtherpadData,
  CreateEtherpadError,
  CreateEtherpadResponse,
  CreateFolderData,
  CreateFolderError,
  CreateFolderResponse,
  CreateFolderWithThumbnailData,
  CreateFolderWithThumbnailError,
  CreateFolderWithThumbnailResponse,
  CreateInvitationData,
  CreateInvitationError,
  CreateInvitationResponse,
  CreateItemData,
  CreateItemError,
  CreateItemFlagData,
  CreateItemFlagError,
  CreateItemFlagResponse,
  CreateItemLikeData,
  CreateItemLikeError,
  CreateItemLikeResponse,
  CreateItemMembershipData,
  CreateItemMembershipError,
  CreateItemMembershipResponse,
  CreateItemResponse,
  CreateItemWithThumbnailData,
  CreateItemWithThumbnailError,
  CreateItemWithThumbnailResponse,
  CreateLinkData,
  CreateLinkError,
  CreateLinkResponse,
  CreateMembershipRequestData,
  CreateMembershipRequestResponse,
  CreateOwnProfileData,
  CreateOwnProfileError,
  CreateOwnProfileResponse,
  CreateShortLinkData,
  CreateShortLinkError,
  CreateShortLinkResponse,
  CreateShortcutData,
  CreateShortcutError,
  CreateShortcutResponse,
  CreateTagForItemData,
  CreateTagForItemError,
  CreateTagForItemResponse,
  CreateVisibilityData,
  CreateVisibilityError,
  CreateVisibilityResponse,
  DeleteAliasData,
  DeleteAliasError,
  DeleteAliasResponse,
  DeleteAppDataData,
  DeleteAppDataError,
  DeleteAppDataResponse,
  DeleteAppSettingData,
  DeleteAppSettingError,
  DeleteAppSettingResponse,
  DeleteBookmarkData,
  DeleteBookmarkError,
  DeleteBookmarkResponse,
  DeleteChatMessageData,
  DeleteChatMessageError,
  DeleteChatMessageResponse,
  DeleteCurrentAccountData,
  DeleteCurrentAccountError,
  DeleteCurrentAccountResponse,
  DeleteGeolocationData,
  DeleteGeolocationError,
  DeleteGeolocationResponse,
  DeleteInvitationData,
  DeleteInvitationError,
  DeleteInvitationResponse,
  DeleteItemLikeData,
  DeleteItemLikeError,
  DeleteItemLikeResponse,
  DeleteItemLoginSchemaData,
  DeleteItemLoginSchemaError,
  DeleteItemMembershipData,
  DeleteItemMembershipError,
  DeleteItemMembershipResponse,
  DeleteItemsByIdThumbnailsData,
  DeleteManyItemsData,
  DeleteManyItemsError,
  DeleteManyItemsResponse,
  DeleteMembersMembersByIdDeleteData,
  DeleteMembershipRequestData,
  DeleteMembershipRequestResponse,
  DeleteMentionData,
  DeleteMentionError,
  DeleteMentionResponse,
  DeleteTagForItemData,
  DeleteTagForItemError,
  DeleteTagForItemResponse,
  DeleteVisibilityData,
  DeleteVisibilityError,
  DeleteVisibilityResponse,
  DownloadAppDataFileData,
  DownloadAppSettingFileData,
  DownloadAvatarData,
  DownloadFileData,
  DownloadFileError,
  DownloadItemThumbnailData,
  EnrollData,
  EnrollResponse,
  ExportActionsData,
  ExportActionsError,
  ExportActionsResponse,
  ExportMemberDataData,
  ExportMemberDataError,
  ExportMemberDataResponse,
  ExportZipData,
  ExportZipError,
  GenerateAppTokenData,
  GenerateAppTokenError,
  GenerateAppTokenResponse,
  GeolocationReverseData,
  GeolocationSearchData,
  GetAccessibleItemsData,
  GetAccessibleItemsError,
  GetAccessibleItemsResponse,
  GetAppActionsForAppData,
  GetAppContextData,
  GetAppDataForAppData,
  GetAppListData,
  GetAppSettingsForAppData,
  GetChatData,
  GetChildrenData,
  GetCollectionInformationsData,
  GetCollectionsForMemberData,
  GetCountForTagsData,
  GetCurrentAccountData,
  GetDescendantItemsData,
  GetEtherpadFromItemData,
  GetFacetsForNameData,
  GetFacetsForNameError,
  GetFacetsForNameResponse,
  GetFeaturedCollectionsData,
  GetFlagTypesData,
  GetGeolocationByItemData,
  GetInvitationByIdData,
  GetInvitationForItemData,
  GetItemActionsByDayData,
  GetItemActionsByHourData,
  GetItemActionsByWeekdayData,
  GetItemData,
  GetItemLoginSchemaData,
  GetItemLoginSchemaTypeData,
  GetItemMembershipsForItemData,
  GetItemsCollectionsSearchRebuildData,
  GetItemsH5pAssetsIntegrationHtmlData,
  GetItemsInBoxData,
  GetItemsPublicationByItemIdStatusData,
  GetLatestItemValidationGroupData,
  GetLikesForCurrentMemberData,
  GetLikesForItemData,
  GetLinkMetadataData,
  GetLogoutData,
  GetMemberProfileData,
  GetMembersActionsData,
  GetMembersCurrentPasswordStatusData,
  GetMembershipRequestsByItemIdData,
  GetMostLikedCollectionsData,
  GetMostRecentCollectionsData,
  GetNextMaintenanceData,
  GetOneMemberData,
  GetOwnBookmarkData,
  GetOwnMembershipRequestByItemIdData,
  GetOwnMentionsData,
  GetOwnMostUsedAppsData,
  GetOwnProfileData,
  GetOwnRecycledItemsData,
  GetOwnRecycledItemsError,
  GetOwnRecycledItemsResponse,
  GetParentItemsData,
  GetShortLinkAvailabilityData,
  GetShortLinkRedirectionData,
  GetShortLinksForItemData,
  GetStatusData,
  GetStorageData,
  GetStorageFilesData,
  GetStorageFilesError,
  GetStorageFilesResponse,
  GetTagsForItemData,
  GetUrlData,
  GetVersionData,
  GetWsData,
  GraaspZipExportData,
  GraaspZipExportError,
  HealthData,
  ImportH5pData,
  ImportH5pError,
  ImportH5pResponse,
  ImportZipData,
  ImportZipError,
  InviteFromCsvData,
  InviteFromCsvError,
  InviteFromCsvResponse,
  InviteFromCsvWithTemplateData,
  InviteFromCsvWithTemplateError,
  InviteFromCsvWithTemplateResponse,
  LoginData,
  LoginError,
  LoginOrRegisterAsGuestData,
  LoginOrRegisterAsGuestError,
  LoginOrRegisterAsGuestResponse,
  LoginResponse,
  MoveManyItemsData,
  MoveManyItemsError,
  MoveManyItemsResponse,
  PatchChangeEmailData,
  PatchChangeEmailError,
  PatchChangeEmailResponse,
  PatchChatMessageData,
  PatchChatMessageError,
  PatchChatMessageResponse,
  PatchMentionData,
  PatchMentionError,
  PatchMentionResponse,
  PatchPasswordData,
  PatchPasswordError,
  PatchPasswordResetData,
  PatchPasswordResponse,
  PostActionData,
  PostActionError,
  PostActionResponse,
  PostChangeEmailData,
  PostChangeEmailError,
  PostChangeEmailResponse,
  PostItemsByIdThumbnailsData,
  PostItemsByIdThumbnailsError,
  PostItemsByIdThumbnailsResponse,
  PostLoginPasswordData,
  PostMembersAvatarData,
  PostMembersAvatarResponse,
  PostPasswordData,
  PostPasswordError,
  PostPasswordResetData,
  PostPasswordResponse,
  PublishItemData,
  PublishItemError,
  PublishItemResponse,
  PutGeolocationData,
  PutGeolocationError,
  PutGeolocationResponse,
  RecycleManyItemsData,
  RecycleManyItemsError,
  RecycleManyItemsResponse,
  RegisterData,
  RegisterError,
  RegisterResponse,
  ReorderItemData,
  ReorderItemError,
  ReorderItemResponse,
  RestoreManyItemsData,
  RestoreManyItemsError,
  RestoreManyItemsResponse,
  SendInvitationData,
  SendInvitationError,
  SendInvitationResponse,
  UnpublishItemData,
  UnpublishItemError,
  UnpublishItemResponse,
  UpdateAppData,
  UpdateAppDataData,
  UpdateAppDataError,
  UpdateAppDataResponse,
  UpdateAppError,
  UpdateAppResponse,
  UpdateAppSettingData,
  UpdateAppSettingError,
  UpdateAppSettingResponse,
  UpdateCurrentAccountData,
  UpdateCurrentAccountError,
  UpdateCurrentAccountResponse,
  UpdateDocumentData,
  UpdateDocumentError,
  UpdateDocumentResponse,
  UpdateEtherpadData,
  UpdateEtherpadError,
  UpdateEtherpadResponse,
  UpdateFileData,
  UpdateFileError,
  UpdateFolderData,
  UpdateFolderError,
  UpdateFolderResponse,
  UpdateInvitationData,
  UpdateInvitationError,
  UpdateInvitationResponse,
  UpdateItemData,
  UpdateItemError,
  UpdateItemLoginSchemaData,
  UpdateItemLoginSchemaError,
  UpdateItemMembershipData,
  UpdateItemMembershipError,
  UpdateItemMembershipResponse,
  UpdateItemResponse,
  UpdateLinkData,
  UpdateLinkError,
  UpdateLinkResponse,
  UpdateOwnProfileData,
  UpdateOwnProfileError,
  UpdateOwnProfileResponse,
  UpdateShortLinkData,
  UpdateShortLinkError,
  UpdateShortLinkResponse,
  UpdateShortcutData,
  UpdateShortcutError,
  UpdateShortcutResponse,
  UploadFileData,
  UploadFileError,
  UploadFileResponse,
  ValidateItemData,
  ValidateItemError,
  ValidateItemResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const healthQueryKey = (options?: Options<HealthData>) =>
  createQueryKey('health', options);

/**
 * Health check endpoint
 * Return a simple 200: OK when the server is running
 */
export const healthOptions = (options?: Options<HealthData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await health({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthQueryKey(options),
  });
};

export const getStatusQueryKey = (options?: Options<GetStatusData>) =>
  createQueryKey('getStatus', options);

export const getStatusOptions = (options?: Options<GetStatusData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStatusQueryKey(options),
  });
};

export const getVersionQueryKey = (options?: Options<GetVersionData>) =>
  createQueryKey('getVersion', options);

export const getVersionOptions = (options?: Options<GetVersionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getVersion({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getVersionQueryKey(options),
  });
};

export const getNextMaintenanceQueryKey = (
  options?: Options<GetNextMaintenanceData>,
) => createQueryKey('getNextMaintenance', options);

/**
 * get next maintenance period
 * Return next maintenance period, usually to perform a migration
 */
export const getNextMaintenanceOptions = (
  options?: Options<GetNextMaintenanceData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getNextMaintenance({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getNextMaintenanceQueryKey(options),
  });
};

export const registerQueryKey = (options: Options<RegisterData>) =>
  createQueryKey('register', options);

/**
 * Register with email and name
 * Register with email and name, protected by a captcha. The captcha is used to prevent brute force attacks.
 */
export const registerOptions = (options: Options<RegisterData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await register({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: registerQueryKey(options),
  });
};

/**
 * Register with email and name
 * Register with email and name, protected by a captcha. The captcha is used to prevent brute force attacks.
 */
export const registerMutation = (
  options?: Partial<Options<RegisterData>>,
): UseMutationOptions<
  RegisterResponse,
  RegisterError,
  Options<RegisterData>
> => {
  const mutationOptions: UseMutationOptions<
    RegisterResponse,
    RegisterError,
    Options<RegisterData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await register({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loginQueryKey = (options: Options<LoginData>) =>
  createQueryKey('login', options);

/**
 * Login with email
 * Login with email, protected by a captcha. The captcha is used to prevent brute force attacks.
 */
export const loginOptions = (options: Options<LoginData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await login({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginQueryKey(options),
  });
};

/**
 * Login with email
 * Login with email, protected by a captcha. The captcha is used to prevent brute force attacks.
 */
export const loginMutation = (
  options?: Partial<Options<LoginData>>,
): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
  const mutationOptions: UseMutationOptions<
    LoginResponse,
    LoginError,
    Options<LoginData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await login({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authenticateQueryKey = (options: Options<AuthenticateData>) =>
  createQueryKey('authenticate', options);

/**
 * Authentication validating the token
 * Authenticate to obtain session cookie given provided token and verifier
 */
export const authenticateOptions = (options: Options<AuthenticateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticateQueryKey(options),
  });
};

export const getLogoutQueryKey = (options?: Options<GetLogoutData>) =>
  createQueryKey('getLogout', options);

export const getLogoutOptions = (options?: Options<GetLogoutData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLogout({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLogoutQueryKey(options),
  });
};

export const postLoginPasswordQueryKey = (
  options: Options<PostLoginPasswordData>,
) => createQueryKey('postLoginPassword', options);

/**
 * Log in with email and password
 * Log in with email and password. The user must provide a valid email, password, and captcha. The captcha is used to prevent brute force attacks.
 */
export const postLoginPasswordOptions = (
  options: Options<PostLoginPasswordData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postLoginPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: postLoginPasswordQueryKey(options),
  });
};

/**
 * Log in with email and password
 * Log in with email and password. The user must provide a valid email, password, and captcha. The captcha is used to prevent brute force attacks.
 */
export const postLoginPasswordMutation = (
  options?: Partial<Options<PostLoginPasswordData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PostLoginPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PostLoginPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postLoginPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update the password of the authenticated member
 * Update the password of the authenticated member. The user must provide the current password and the new password.
 */
export const patchPasswordMutation = (
  options?: Partial<Options<PatchPasswordData>>,
): UseMutationOptions<
  PatchPasswordResponse,
  PatchPasswordError,
  Options<PatchPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    PatchPasswordResponse,
    PatchPasswordError,
    Options<PatchPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await patchPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const postPasswordQueryKey = (options: Options<PostPasswordData>) =>
  createQueryKey('postPassword', options);

/**
 * Set a password for the authenticated member
 * Set a password for the authenticated member. This is only possible if the member does not have a password set already.
 */
export const postPasswordOptions = (options: Options<PostPasswordData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: postPasswordQueryKey(options),
  });
};

/**
 * Set a password for the authenticated member
 * Set a password for the authenticated member. This is only possible if the member does not have a password set already.
 */
export const postPasswordMutation = (
  options?: Partial<Options<PostPasswordData>>,
): UseMutationOptions<
  PostPasswordResponse,
  PostPasswordError,
  Options<PostPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    PostPasswordResponse,
    PostPasswordError,
    Options<PostPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Confirm the reset password request
 * Confirm the reset password request. This will change the password of the member associated with the reset password request.
 */
export const patchPasswordResetMutation = (
  options?: Partial<Options<PatchPasswordResetData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PatchPasswordResetData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PatchPasswordResetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await patchPasswordReset({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const postPasswordResetQueryKey = (
  options: Options<PostPasswordResetData>,
) => createQueryKey('postPasswordReset', options);

/**
 * Create a reset password request
 * Create a reset password request. This will send an email to the member in his language with a link to reset the password. The link will be valid for a limited time.
 */
export const postPasswordResetOptions = (
  options: Options<PostPasswordResetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postPasswordReset({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: postPasswordResetQueryKey(options),
  });
};

/**
 * Create a reset password request
 * Create a reset password request. This will send an email to the member in his language with a link to reset the password. The link will be valid for a limited time.
 */
export const postPasswordResetMutation = (
  options?: Partial<Options<PostPasswordResetData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PostPasswordResetData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PostPasswordResetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postPasswordReset({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMembersCurrentPasswordStatusQueryKey = (
  options?: Options<GetMembersCurrentPasswordStatusData>,
) => createQueryKey('getMembersCurrentPasswordStatus', options);

/**
 * Get the current password status of the authenticated member
 * Return whether the authenticated member has a password defined.
 */
export const getMembersCurrentPasswordStatusOptions = (
  options?: Options<GetMembersCurrentPasswordStatusData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMembersCurrentPasswordStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMembersCurrentPasswordStatusQueryKey(options),
  });
};

export const getWsQueryKey = (options?: Options<GetWsData>) =>
  createQueryKey('getWs', options);

export const getWsOptions = (options?: Options<GetWsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getWs({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getWsQueryKey(options),
  });
};

export const getMembersActionsQueryKey = (
  options?: Options<GetMembersActionsData>,
) => createQueryKey('getMembersActions', options);

export const getMembersActionsOptions = (
  options?: Options<GetMembersActionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMembersActions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMembersActionsQueryKey(options),
  });
};

export const deleteMembersMembersByIdDeleteMutation = (
  options?: Partial<Options<DeleteMembersMembersByIdDeleteData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<DeleteMembersMembersByIdDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<DeleteMembersMembersByIdDeleteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteMembersMembersByIdDelete({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete authenticated account
 * Delete authenticated account. This action is irreversible!
 */
export const deleteCurrentAccountMutation = (
  options?: Partial<Options<DeleteCurrentAccountData>>,
): UseMutationOptions<
  DeleteCurrentAccountResponse,
  DeleteCurrentAccountError,
  Options<DeleteCurrentAccountData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteCurrentAccountResponse,
    DeleteCurrentAccountError,
    Options<DeleteCurrentAccountData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteCurrentAccount({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentAccountQueryKey = (
  options?: Options<GetCurrentAccountData>,
) => createQueryKey('getCurrentAccount', options);

/**
 * Get information of current authenticated account
 * Get information of current authenticated account, that can be a member or a guest.
 */
export const getCurrentAccountOptions = (
  options?: Options<GetCurrentAccountData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentAccount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentAccountQueryKey(options),
  });
};

/**
 * Update authenticated account
 * Update authenticated account, such as name or language.
 */
export const updateCurrentAccountMutation = (
  options?: Partial<Options<UpdateCurrentAccountData>>,
): UseMutationOptions<
  UpdateCurrentAccountResponse,
  UpdateCurrentAccountError,
  Options<UpdateCurrentAccountData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCurrentAccountResponse,
    UpdateCurrentAccountError,
    Options<UpdateCurrentAccountData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateCurrentAccount({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getStorageQueryKey = (options?: Options<GetStorageData>) =>
  createQueryKey('getStorage', options);

/**
 * Get storage values
 * Get amount of storage used for current member, and its maximum storage value.
 */
export const getStorageOptions = (options?: Options<GetStorageData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStorage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStorageQueryKey(options),
  });
};

export const getStorageFilesQueryKey = (
  options: Options<GetStorageFilesData>,
) => createQueryKey('getStorageFiles', options);

/**
 * Get storage files data
 * Get files data counted in storage of current member.
 */
export const getStorageFilesOptions = (
  options: Options<GetStorageFilesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStorageFiles({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStorageFilesQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const getStorageFilesInfiniteQueryKey = (
  options: Options<GetStorageFilesData>,
): QueryKey<Options<GetStorageFilesData>> =>
  createQueryKey('getStorageFiles', options, true);

/**
 * Get storage files data
 * Get files data counted in storage of current member.
 */
export const getStorageFilesInfiniteOptions = (
  options: Options<GetStorageFilesData>,
) => {
  return infiniteQueryOptions<
    GetStorageFilesResponse,
    GetStorageFilesError,
    InfiniteData<GetStorageFilesResponse>,
    QueryKey<Options<GetStorageFilesData>>,
    | number
    | Pick<
        QueryKey<Options<GetStorageFilesData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetStorageFilesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStorageFiles({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getStorageFilesInfiniteQueryKey(options),
    },
  );
};

export const getOneMemberQueryKey = (options: Options<GetOneMemberData>) =>
  createQueryKey('getOneMember', options);

/**
 * Get member by id
 * Get member by id.
 */
export const getOneMemberOptions = (options: Options<GetOneMemberData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOneMember({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOneMemberQueryKey(options),
  });
};

/**
 * Change email
 * Change email for current authenticated member.
 */
export const patchChangeEmailMutation = (
  options?: Partial<Options<PatchChangeEmailData>>,
): UseMutationOptions<
  PatchChangeEmailResponse,
  PatchChangeEmailError,
  Options<PatchChangeEmailData>
> => {
  const mutationOptions: UseMutationOptions<
    PatchChangeEmailResponse,
    PatchChangeEmailError,
    Options<PatchChangeEmailData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await patchChangeEmail({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const postChangeEmailQueryKey = (
  options: Options<PostChangeEmailData>,
) => createQueryKey('postChangeEmail', options);

/**
 * Request to change email
 * Request to change email for current authenticated member.
 */
export const postChangeEmailOptions = (
  options: Options<PostChangeEmailData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postChangeEmail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: postChangeEmailQueryKey(options),
  });
};

/**
 * Request to change email
 * Request to change email for current authenticated member.
 */
export const postChangeEmailMutation = (
  options?: Partial<Options<PostChangeEmailData>>,
): UseMutationOptions<
  PostChangeEmailResponse,
  PostChangeEmailError,
  Options<PostChangeEmailData>
> => {
  const mutationOptions: UseMutationOptions<
    PostChangeEmailResponse,
    PostChangeEmailError,
    Options<PostChangeEmailData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postChangeEmail({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const postMembersAvatarQueryKey = (
  options?: Options<PostMembersAvatarData>,
) => createQueryKey('postMembersAvatar', options);

export const postMembersAvatarOptions = (
  options?: Options<PostMembersAvatarData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postMembersAvatar({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: postMembersAvatarQueryKey(options),
  });
};

export const postMembersAvatarMutation = (
  options?: Partial<Options<PostMembersAvatarData>>,
): UseMutationOptions<
  PostMembersAvatarResponse,
  DefaultError,
  Options<PostMembersAvatarData>
> => {
  const mutationOptions: UseMutationOptions<
    PostMembersAvatarResponse,
    DefaultError,
    Options<PostMembersAvatarData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postMembersAvatar({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const downloadAvatarQueryKey = (options: Options<DownloadAvatarData>) =>
  createQueryKey('downloadAvatar', options);

/**
 * Get a member's avatar
 * Get a member's avatar at given size. The return value is empty if the member did not previously uploaded an avatar. Since guests don't have avatars, the return value will also be empty.
 */
export const downloadAvatarOptions = (options: Options<DownloadAvatarData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await downloadAvatar({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: downloadAvatarQueryKey(options),
  });
};

export const getOwnProfileQueryKey = (options?: Options<GetOwnProfileData>) =>
  createQueryKey('getOwnProfile', options);

/**
 * Get profile of current member
 * Get profile of current member
 */
export const getOwnProfileOptions = (options?: Options<GetOwnProfileData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnProfile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnProfileQueryKey(options),
  });
};

export const getMemberProfileQueryKey = (
  options: Options<GetMemberProfileData>,
) => createQueryKey('getMemberProfile', options);

/**
 * Get profile of given member
 * Get profile of given member
 */
export const getMemberProfileOptions = (
  options: Options<GetMemberProfileData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMemberProfile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMemberProfileQueryKey(options),
  });
};

/**
 * Update profile of current member
 * Update profile of current member
 */
export const updateOwnProfileMutation = (
  options?: Partial<Options<UpdateOwnProfileData>>,
): UseMutationOptions<
  UpdateOwnProfileResponse,
  UpdateOwnProfileError,
  Options<UpdateOwnProfileData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateOwnProfileResponse,
    UpdateOwnProfileError,
    Options<UpdateOwnProfileData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateOwnProfile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createOwnProfileQueryKey = (
  options?: Options<CreateOwnProfileData>,
) => createQueryKey('createOwnProfile', options);

/**
 * Create profile for current member
 * Create profile for current member.
 */
export const createOwnProfileOptions = (
  options?: Options<CreateOwnProfileData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createOwnProfile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createOwnProfileQueryKey(options),
  });
};

/**
 * Create profile for current member
 * Create profile for current member.
 */
export const createOwnProfileMutation = (
  options?: Partial<Options<CreateOwnProfileData>>,
): UseMutationOptions<
  CreateOwnProfileResponse,
  CreateOwnProfileError,
  Options<CreateOwnProfileData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateOwnProfileResponse,
    CreateOwnProfileError,
    Options<CreateOwnProfileData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createOwnProfile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const exportMemberDataQueryKey = (
  options?: Options<ExportMemberDataData>,
) => createQueryKey('exportMemberData', options);

/**
 * Request all related data of authenticated member
 * Request a download link to have access to all data related to the authenticated user. The link is valid for one week.
 */
export const exportMemberDataOptions = (
  options?: Options<ExportMemberDataData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await exportMemberData({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: exportMemberDataQueryKey(options),
  });
};

/**
 * Request all related data of authenticated member
 * Request a download link to have access to all data related to the authenticated user. The link is valid for one week.
 */
export const exportMemberDataMutation = (
  options?: Partial<Options<ExportMemberDataData>>,
): UseMutationOptions<
  ExportMemberDataResponse,
  ExportMemberDataError,
  Options<ExportMemberDataData>
> => {
  const mutationOptions: UseMutationOptions<
    ExportMemberDataResponse,
    ExportMemberDataError,
    Options<ExportMemberDataData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await exportMemberData({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAppListQueryKey = (options?: Options<GetAppListData>) =>
  createQueryKey('getAppList', options);

/**
 * Get list of available apps
 * Get list of available apps
 */
export const getAppListOptions = (options?: Options<GetAppListData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAppList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAppListQueryKey(options),
  });
};

export const getOwnMostUsedAppsQueryKey = (
  options?: Options<GetOwnMostUsedAppsData>,
) => createQueryKey('getOwnMostUsedApps', options);

/**
 * Get the user's most used apps
 * Get a list of the apps the user has used the most to ease the addition of new apps.
 */
export const getOwnMostUsedAppsOptions = (
  options?: Options<GetOwnMostUsedAppsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnMostUsedApps({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnMostUsedAppsQueryKey(options),
  });
};

export const generateAppTokenQueryKey = (
  options: Options<GenerateAppTokenData>,
) => createQueryKey('generateAppToken', options);

/**
 * Generate auth token for an app
 * Generate auth token for an app to access app API
 */
export const generateAppTokenOptions = (
  options: Options<GenerateAppTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateAppToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateAppTokenQueryKey(options),
  });
};

/**
 * Generate auth token for an app
 * Generate auth token for an app to access app API
 */
export const generateAppTokenMutation = (
  options?: Partial<Options<GenerateAppTokenData>>,
): UseMutationOptions<
  GenerateAppTokenResponse,
  GenerateAppTokenError,
  Options<GenerateAppTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateAppTokenResponse,
    GenerateAppTokenError,
    Options<GenerateAppTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await generateAppToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAppContextQueryKey = (options: Options<GetAppContextData>) =>
  createQueryKey('getAppContext', options);

/**
 * Get context information of an app
 * Get context information of an app
 */
export const getAppContextOptions = (options: Options<GetAppContextData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAppContext({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAppContextQueryKey(options),
  });
};

export const getAppDataForAppQueryKey = (
  options: Options<GetAppDataForAppData>,
) => createQueryKey('getAppDataForApp', options);

/**
 * Get all app data of an app
 * Get app data saved for an app, depending on the permission of the user and the data visibility.
 */
export const getAppDataForAppOptions = (
  options: Options<GetAppDataForAppData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAppDataForApp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAppDataForAppQueryKey(options),
  });
};

export const createAppDataQueryKey = (options: Options<CreateAppDataData>) =>
  createQueryKey('createAppData', options);

/**
 * Create a user data for an app
 * Create a user data in an app given data and type.
 */
export const createAppDataOptions = (options: Options<CreateAppDataData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAppData({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAppDataQueryKey(options),
  });
};

/**
 * Create a user data for an app
 * Create a user data in an app given data and type.
 */
export const createAppDataMutation = (
  options?: Partial<Options<CreateAppDataData>>,
): UseMutationOptions<
  CreateAppDataResponse,
  CreateAppDataError,
  Options<CreateAppDataData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAppDataResponse,
    CreateAppDataError,
    Options<CreateAppDataData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAppData({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an app data
 * Delete a given app data.
 */
export const deleteAppDataMutation = (
  options?: Partial<Options<DeleteAppDataData>>,
): UseMutationOptions<
  DeleteAppDataResponse,
  DeleteAppDataError,
  Options<DeleteAppDataData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAppDataResponse,
    DeleteAppDataError,
    Options<DeleteAppDataData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAppData({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update an app data
 * Update a given app data with new data.
 */
export const updateAppDataMutation = (
  options?: Partial<Options<UpdateAppDataData>>,
): UseMutationOptions<
  UpdateAppDataResponse,
  UpdateAppDataError,
  Options<UpdateAppDataData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAppDataResponse,
    UpdateAppDataError,
    Options<UpdateAppDataData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateAppData({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createAppDataFileQueryKey = (
  options?: Options<CreateAppDataFileData>,
) => createQueryKey('createAppDataFile', options);

/**
 * Create app data file
 * Upload a file to create a corresponding app data. The created app data will be "file" and visibility member. The data property will contain the file properties.
 */
export const createAppDataFileOptions = (
  options?: Options<CreateAppDataFileData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAppDataFile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAppDataFileQueryKey(options),
  });
};

/**
 * Create app data file
 * Upload a file to create a corresponding app data. The created app data will be "file" and visibility member. The data property will contain the file properties.
 */
export const createAppDataFileMutation = (
  options?: Partial<Options<CreateAppDataFileData>>,
): UseMutationOptions<
  unknown,
  CreateAppDataFileError,
  Options<CreateAppDataFileData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    CreateAppDataFileError,
    Options<CreateAppDataFileData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAppDataFile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const downloadAppDataFileQueryKey = (
  options: Options<DownloadAppDataFileData>,
) => createQueryKey('downloadAppDataFile', options);

/**
 * Download app data file
 * Download app data file.
 */
export const downloadAppDataFileOptions = (
  options: Options<DownloadAppDataFileData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await downloadAppDataFile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: downloadAppDataFileQueryKey(options),
  });
};

export const getAppActionsForAppQueryKey = (
  options: Options<GetAppActionsForAppData>,
) => createQueryKey('getAppActionsForApp', options);

/**
 * Get all actions of an app
 * Get all actions saved for an app.
 */
export const getAppActionsForAppOptions = (
  options: Options<GetAppActionsForAppData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAppActionsForApp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAppActionsForAppQueryKey(options),
  });
};

export const createAppActionQueryKey = (
  options: Options<CreateAppActionData>,
) => createQueryKey('createAppAction', options);

/**
 * Create an action happening in an app
 * Create an action happening in an app given data and type.
 */
export const createAppActionOptions = (
  options: Options<CreateAppActionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAppAction({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAppActionQueryKey(options),
  });
};

/**
 * Create an action happening in an app
 * Create an action happening in an app given data and type.
 */
export const createAppActionMutation = (
  options?: Partial<Options<CreateAppActionData>>,
): UseMutationOptions<
  CreateAppActionResponse,
  CreateAppActionError,
  Options<CreateAppActionData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAppActionResponse,
    CreateAppActionError,
    Options<CreateAppActionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAppAction({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAppSettingsForAppQueryKey = (
  options: Options<GetAppSettingsForAppData>,
) => createQueryKey('getAppSettingsForApp', options);

/**
 * Get all settings of an app
 * Get all settings for an app.
 */
export const getAppSettingsForAppOptions = (
  options: Options<GetAppSettingsForAppData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAppSettingsForApp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAppSettingsForAppQueryKey(options),
  });
};

export const createAppSettingQueryKey = (
  options: Options<CreateAppSettingData>,
) => createQueryKey('createAppSetting', options);

/**
 * Create a setting for an app
 * Create a setting in an app given data and name. Only admins can create settings.
 */
export const createAppSettingOptions = (
  options: Options<CreateAppSettingData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAppSetting({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAppSettingQueryKey(options),
  });
};

/**
 * Create a setting for an app
 * Create a setting in an app given data and name. Only admins can create settings.
 */
export const createAppSettingMutation = (
  options?: Partial<Options<CreateAppSettingData>>,
): UseMutationOptions<
  CreateAppSettingResponse,
  CreateAppSettingError,
  Options<CreateAppSettingData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAppSettingResponse,
    CreateAppSettingError,
    Options<CreateAppSettingData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAppSetting({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete app setting
 * Delete given app setting.
 */
export const deleteAppSettingMutation = (
  options?: Partial<Options<DeleteAppSettingData>>,
): UseMutationOptions<
  DeleteAppSettingResponse,
  DeleteAppSettingError,
  Options<DeleteAppSettingData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAppSettingResponse,
    DeleteAppSettingError,
    Options<DeleteAppSettingData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAppSetting({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update app setting
 * Update given app setting with new data. Only admins can update settings.
 */
export const updateAppSettingMutation = (
  options?: Partial<Options<UpdateAppSettingData>>,
): UseMutationOptions<
  UpdateAppSettingResponse,
  UpdateAppSettingError,
  Options<UpdateAppSettingData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAppSettingResponse,
    UpdateAppSettingError,
    Options<UpdateAppSettingData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateAppSetting({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createAppSettingFileQueryKey = (
  options?: Options<CreateAppSettingFileData>,
) => createQueryKey('createAppSettingFile', options);

/**
 * Create app setting file
 * Upload a file to create a corresponding app setting. The setting's name can be defined in the file body (form data) as "name", otherwise it will default to "file"
 */
export const createAppSettingFileOptions = (
  options?: Options<CreateAppSettingFileData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAppSettingFile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAppSettingFileQueryKey(options),
  });
};

/**
 * Create app setting file
 * Upload a file to create a corresponding app setting. The setting's name can be defined in the file body (form data) as "name", otherwise it will default to "file"
 */
export const createAppSettingFileMutation = (
  options?: Partial<Options<CreateAppSettingFileData>>,
): UseMutationOptions<
  CreateAppSettingFileResponse,
  CreateAppSettingFileError,
  Options<CreateAppSettingFileData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAppSettingFileResponse,
    CreateAppSettingFileError,
    Options<CreateAppSettingFileData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAppSettingFile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const downloadAppSettingFileQueryKey = (
  options: Options<DownloadAppSettingFileData>,
) => createQueryKey('downloadAppSettingFile', options);

/**
 * Download app setting file
 * Download app setting file.
 */
export const downloadAppSettingFileOptions = (
  options: Options<DownloadAppSettingFileData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await downloadAppSettingFile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: downloadAppSettingFileQueryKey(options),
  });
};

export const createChatbotCompletionPromptQueryKey = (
  options: Options<CreateChatbotCompletionPromptData>,
) => createQueryKey('createChatbotCompletionPrompt', options);

/**
 * Get a prompt completion from a chatbot
 * Given a prompt, it returns a completion from a chatbot.
 */
export const createChatbotCompletionPromptOptions = (
  options: Options<CreateChatbotCompletionPromptData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createChatbotCompletionPrompt({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createChatbotCompletionPromptQueryKey(options),
  });
};

/**
 * Get a prompt completion from a chatbot
 * Given a prompt, it returns a completion from a chatbot.
 */
export const createChatbotCompletionPromptMutation = (
  options?: Partial<Options<CreateChatbotCompletionPromptData>>,
): UseMutationOptions<
  CreateChatbotCompletionPromptResponse,
  CreateChatbotCompletionPromptError,
  Options<CreateChatbotCompletionPromptData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateChatbotCompletionPromptResponse,
    CreateChatbotCompletionPromptError,
    Options<CreateChatbotCompletionPromptData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createChatbotCompletionPrompt({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getItemLoginSchemaTypeQueryKey = (
  options: Options<GetItemLoginSchemaTypeData>,
) => createQueryKey('getItemLoginSchemaType', options);

/**
 * Get type of item login
 * Get type of item login. Return null if the item does not allow item login.
 */
export const getItemLoginSchemaTypeOptions = (
  options: Options<GetItemLoginSchemaTypeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemLoginSchemaType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemLoginSchemaTypeQueryKey(options),
  });
};

/**
 * Delete item login schema
 * Delete item login data and all related users.
 */
export const deleteItemLoginSchemaMutation = (
  options?: Partial<Options<DeleteItemLoginSchemaData>>,
): UseMutationOptions<
  unknown,
  DeleteItemLoginSchemaError,
  Options<DeleteItemLoginSchemaData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteItemLoginSchemaError,
    Options<DeleteItemLoginSchemaData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteItemLoginSchema({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getItemLoginSchemaQueryKey = (
  options: Options<GetItemLoginSchemaData>,
) => createQueryKey('getItemLoginSchema', options);

/**
 * Get item login data
 * Get item login data.
 */
export const getItemLoginSchemaOptions = (
  options: Options<GetItemLoginSchemaData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemLoginSchema({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemLoginSchemaQueryKey(options),
  });
};

/**
 * Update item login data
 * Update item login's status and/or type.
 */
export const updateItemLoginSchemaMutation = (
  options?: Partial<Options<UpdateItemLoginSchemaData>>,
): UseMutationOptions<
  unknown,
  UpdateItemLoginSchemaError,
  Options<UpdateItemLoginSchemaData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UpdateItemLoginSchemaError,
    Options<UpdateItemLoginSchemaData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateItemLoginSchema({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loginOrRegisterAsGuestQueryKey = (
  options: Options<LoginOrRegisterAsGuestData>,
) => createQueryKey('loginOrRegisterAsGuest', options);

/**
 * Login or Register in item as guest
 * Log in to an item with necessary credentials depending on item login's type. If the username does not exist, a guest account is created and is given access.
 */
export const loginOrRegisterAsGuestOptions = (
  options: Options<LoginOrRegisterAsGuestData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await loginOrRegisterAsGuest({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginOrRegisterAsGuestQueryKey(options),
  });
};

/**
 * Login or Register in item as guest
 * Log in to an item with necessary credentials depending on item login's type. If the username does not exist, a guest account is created and is given access.
 */
export const loginOrRegisterAsGuestMutation = (
  options?: Partial<Options<LoginOrRegisterAsGuestData>>,
): UseMutationOptions<
  LoginOrRegisterAsGuestResponse,
  LoginOrRegisterAsGuestError,
  Options<LoginOrRegisterAsGuestData>
> => {
  const mutationOptions: UseMutationOptions<
    LoginOrRegisterAsGuestResponse,
    LoginOrRegisterAsGuestError,
    Options<LoginOrRegisterAsGuestData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await loginOrRegisterAsGuest({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOwnBookmarkQueryKey = (options?: Options<GetOwnBookmarkData>) =>
  createQueryKey('getOwnBookmark', options);

/**
 * Get all bookmarked instances of the current member
 * Get all bookmarked instances of the current member
 */
export const getOwnBookmarkOptions = (
  options?: Options<GetOwnBookmarkData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnBookmark({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnBookmarkQueryKey(options),
  });
};

/**
 * Remove item from bookmarks
 * Remove item from bookmarks
 */
export const deleteBookmarkMutation = (
  options?: Partial<Options<DeleteBookmarkData>>,
): UseMutationOptions<
  DeleteBookmarkResponse,
  DeleteBookmarkError,
  Options<DeleteBookmarkData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteBookmarkResponse,
    DeleteBookmarkError,
    Options<DeleteBookmarkData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteBookmark({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createBookmarkQueryKey = (options: Options<CreateBookmarkData>) =>
  createQueryKey('createBookmark', options);

/**
 * Bookmark item
 * Bookmark item
 */
export const createBookmarkOptions = (options: Options<CreateBookmarkData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createBookmark({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createBookmarkQueryKey(options),
  });
};

/**
 * Bookmark item
 * Bookmark item
 */
export const createBookmarkMutation = (
  options?: Partial<Options<CreateBookmarkData>>,
): UseMutationOptions<
  CreateBookmarkResponse,
  CreateBookmarkError,
  Options<CreateBookmarkData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateBookmarkResponse,
    CreateBookmarkError,
    Options<CreateBookmarkData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createBookmark({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCollectionsForMemberQueryKey = (
  options: Options<GetCollectionsForMemberData>,
) => createQueryKey('getCollectionsForMember', options);

/**
 * Get collections for member
 * Get packed collections for member, used in the builder view of the member.
 */
export const getCollectionsForMemberOptions = (
  options: Options<GetCollectionsForMemberData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCollectionsForMember({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCollectionsForMemberQueryKey(options),
  });
};

export const getCollectionInformationsQueryKey = (
  options: Options<GetCollectionInformationsData>,
) => createQueryKey('getCollectionInformations', options);

/**
 * Get information of a collection
 * Get information of a collection, including views count.
 */
export const getCollectionInformationsOptions = (
  options: Options<GetCollectionInformationsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCollectionInformations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCollectionInformationsQueryKey(options),
  });
};

export const publishItemQueryKey = (options: Options<PublishItemData>) =>
  createQueryKey('publishItem', options);

/**
 * Publish an item
 * Publish an item. It will become listed in the Library.
 */
export const publishItemOptions = (options: Options<PublishItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await publishItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: publishItemQueryKey(options),
  });
};

/**
 * Publish an item
 * Publish an item. It will become listed in the Library.
 */
export const publishItemMutation = (
  options?: Partial<Options<PublishItemData>>,
): UseMutationOptions<
  PublishItemResponse,
  PublishItemError,
  Options<PublishItemData>
> => {
  const mutationOptions: UseMutationOptions<
    PublishItemResponse,
    PublishItemError,
    Options<PublishItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await publishItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unpublish an item
 * Unpublish an item. It will stop being available in the Library.
 */
export const unpublishItemMutation = (
  options?: Partial<Options<UnpublishItemData>>,
): UseMutationOptions<
  UnpublishItemResponse,
  UnpublishItemError,
  Options<UnpublishItemData>
> => {
  const mutationOptions: UseMutationOptions<
    UnpublishItemResponse,
    UnpublishItemError,
    Options<UnpublishItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await unpublishItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const collectionSearchQueryKey = (
  options?: Options<CollectionSearchData>,
) => createQueryKey('collectionSearch', options);

/**
 * Get collections given search query
 * Get collections given search query. the results are highlighted given the search query.
 */
export const collectionSearchOptions = (
  options?: Options<CollectionSearchData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await collectionSearch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: collectionSearchQueryKey(options),
  });
};

export const collectionSearchInfiniteQueryKey = (
  options?: Options<CollectionSearchData>,
): QueryKey<Options<CollectionSearchData>> =>
  createQueryKey('collectionSearch', options, true);

/**
 * Get collections given search query
 * Get collections given search query. the results are highlighted given the search query.
 */
export const collectionSearchInfiniteOptions = (
  options?: Options<CollectionSearchData>,
) => {
  return infiniteQueryOptions<
    CollectionSearchResponse,
    CollectionSearchError,
    InfiniteData<CollectionSearchResponse>,
    QueryKey<Options<CollectionSearchData>>,
    | number
    | Pick<
        QueryKey<Options<CollectionSearchData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<CollectionSearchData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await collectionSearch({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: collectionSearchInfiniteQueryKey(options),
    },
  );
};

/**
 * Get collections given search query
 * Get collections given search query. the results are highlighted given the search query.
 */
export const collectionSearchMutation = (
  options?: Partial<Options<CollectionSearchData>>,
): UseMutationOptions<
  CollectionSearchResponse,
  CollectionSearchError,
  Options<CollectionSearchData>
> => {
  const mutationOptions: UseMutationOptions<
    CollectionSearchResponse,
    CollectionSearchError,
    Options<CollectionSearchData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await collectionSearch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFacetsForNameQueryKey = (
  options: Options<GetFacetsForNameData>,
) => createQueryKey('getFacetsForName', options);

/**
 * Get facets for a given facet name
 * Get list of facets and how many collections are tagged with those given a facet name.
 */
export const getFacetsForNameOptions = (
  options: Options<GetFacetsForNameData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFacetsForName({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFacetsForNameQueryKey(options),
  });
};

/**
 * Get facets for a given facet name
 * Get list of facets and how many collections are tagged with those given a facet name.
 */
export const getFacetsForNameMutation = (
  options?: Partial<Options<GetFacetsForNameData>>,
): UseMutationOptions<
  GetFacetsForNameResponse,
  GetFacetsForNameError,
  Options<GetFacetsForNameData>
> => {
  const mutationOptions: UseMutationOptions<
    GetFacetsForNameResponse,
    GetFacetsForNameError,
    Options<GetFacetsForNameData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await getFacetsForName({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFeaturedCollectionsQueryKey = (
  options?: Options<GetFeaturedCollectionsData>,
) => createQueryKey('getFeaturedCollections', options);

/**
 * Get featured collections
 * Get collections that we want to feature on the library home page.
 */
export const getFeaturedCollectionsOptions = (
  options?: Options<GetFeaturedCollectionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFeaturedCollections({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFeaturedCollectionsQueryKey(options),
  });
};

export const getMostLikedCollectionsQueryKey = (
  options?: Options<GetMostLikedCollectionsData>,
) => createQueryKey('getMostLikedCollections', options);

/**
 * Get most liked collections
 * Get most liked collections.
 */
export const getMostLikedCollectionsOptions = (
  options?: Options<GetMostLikedCollectionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMostLikedCollections({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMostLikedCollectionsQueryKey(options),
  });
};

export const getMostRecentCollectionsQueryKey = (
  options?: Options<GetMostRecentCollectionsData>,
) => createQueryKey('getMostRecentCollections', options);

/**
 * Get most recent collections
 * Get most recently published and modified collections
 */
export const getMostRecentCollectionsOptions = (
  options?: Options<GetMostRecentCollectionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMostRecentCollections({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMostRecentCollectionsQueryKey(options),
  });
};

export const getItemsCollectionsSearchRebuildQueryKey = (
  options?: Options<GetItemsCollectionsSearchRebuildData>,
) => createQueryKey('getItemsCollectionsSearchRebuild', options);

export const getItemsCollectionsSearchRebuildOptions = (
  options?: Options<GetItemsCollectionsSearchRebuildData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemsCollectionsSearchRebuild({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemsCollectionsSearchRebuildQueryKey(options),
  });
};

export const getItemMembershipsForItemQueryKey = (
  options: Options<GetItemMembershipsForItemData>,
) => createQueryKey('getItemMembershipsForItem', options);

/**
 * Get memberships for one item
 * Get memberships for one item
 */
export const getItemMembershipsForItemOptions = (
  options: Options<GetItemMembershipsForItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemMembershipsForItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemMembershipsForItemQueryKey(options),
  });
};

export const createItemMembershipQueryKey = (
  options: Options<CreateItemMembershipData>,
) => createQueryKey('createItemMembership', options);

/**
 * Create access to item for account
 * Create access to item for account, given permission
 */
export const createItemMembershipOptions = (
  options: Options<CreateItemMembershipData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createItemMembership({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createItemMembershipQueryKey(options),
  });
};

/**
 * Create access to item for account
 * Create access to item for account, given permission
 */
export const createItemMembershipMutation = (
  options?: Partial<Options<CreateItemMembershipData>>,
): UseMutationOptions<
  CreateItemMembershipResponse,
  CreateItemMembershipError,
  Options<CreateItemMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateItemMembershipResponse,
    CreateItemMembershipError,
    Options<CreateItemMembershipData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createItemMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete access to item for account
 * Delete access to item for account
 */
export const deleteItemMembershipMutation = (
  options?: Partial<Options<DeleteItemMembershipData>>,
): UseMutationOptions<
  DeleteItemMembershipResponse,
  DeleteItemMembershipError,
  Options<DeleteItemMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteItemMembershipResponse,
    DeleteItemMembershipError,
    Options<DeleteItemMembershipData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteItemMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update permission for item membership
 * Update permission for item membership
 */
export const updateItemMembershipMutation = (
  options?: Partial<Options<UpdateItemMembershipData>>,
): UseMutationOptions<
  UpdateItemMembershipResponse,
  UpdateItemMembershipError,
  Options<UpdateItemMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateItemMembershipResponse,
    UpdateItemMembershipError,
    Options<UpdateItemMembershipData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateItemMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMembershipRequestsByItemIdQueryKey = (
  options: Options<GetMembershipRequestsByItemIdData>,
) => createQueryKey('getMembershipRequestsByItemId', options);

/**
 * Get all membership requests for an item
 * Get all membership requests with member information for an item by its ID
 */
export const getMembershipRequestsByItemIdOptions = (
  options: Options<GetMembershipRequestsByItemIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMembershipRequestsByItemId({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMembershipRequestsByItemIdQueryKey(options),
  });
};

export const createMembershipRequestQueryKey = (
  options: Options<CreateMembershipRequestData>,
) => createQueryKey('createMembershipRequest', options);

/**
 * Create a membership request
 * Create a membership request for an item with the authenticated member.
 * The member should not have any permission on the item.
 * If there is an Item Login associated with the item, the request will be rejected.
 */
export const createMembershipRequestOptions = (
  options: Options<CreateMembershipRequestData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createMembershipRequest({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createMembershipRequestQueryKey(options),
  });
};

/**
 * Create a membership request
 * Create a membership request for an item with the authenticated member.
 * The member should not have any permission on the item.
 * If there is an Item Login associated with the item, the request will be rejected.
 */
export const createMembershipRequestMutation = (
  options?: Partial<Options<CreateMembershipRequestData>>,
): UseMutationOptions<
  CreateMembershipRequestResponse,
  DefaultError,
  Options<CreateMembershipRequestData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateMembershipRequestResponse,
    DefaultError,
    Options<CreateMembershipRequestData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createMembershipRequest({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOwnMembershipRequestByItemIdQueryKey = (
  options: Options<GetOwnMembershipRequestByItemIdData>,
) => createQueryKey('getOwnMembershipRequestByItemId', options);

/**
 * Get the status of the membership request for the authenticated member
 * Get the status of the membership request for the authenticated member for an item by its ID
 */
export const getOwnMembershipRequestByItemIdOptions = (
  options: Options<GetOwnMembershipRequestByItemIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnMembershipRequestByItemId({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnMembershipRequestByItemIdQueryKey(options),
  });
};

/**
 * Delete a membership request
 * Delete a membership request from a member id and an item id.
 */
export const deleteMembershipRequestMutation = (
  options?: Partial<Options<DeleteMembershipRequestData>>,
): UseMutationOptions<
  DeleteMembershipRequestResponse,
  DefaultError,
  Options<DeleteMembershipRequestData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteMembershipRequestResponse,
    DefaultError,
    Options<DeleteMembershipRequestData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteMembershipRequest({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createShortcutQueryKey = (options: Options<CreateShortcutData>) =>
  createQueryKey('createShortcut', options);

/**
 * Create shortcut
 * Create shortcut. If not provided, the name of the shortcut is infered from the actor's language.
 */
export const createShortcutOptions = (options: Options<CreateShortcutData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createShortcut({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createShortcutQueryKey(options),
  });
};

/**
 * Create shortcut
 * Create shortcut. If not provided, the name of the shortcut is infered from the actor's language.
 */
export const createShortcutMutation = (
  options?: Partial<Options<CreateShortcutData>>,
): UseMutationOptions<
  CreateShortcutResponse,
  CreateShortcutError,
  Options<CreateShortcutData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateShortcutResponse,
    CreateShortcutError,
    Options<CreateShortcutData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createShortcut({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update shortcut
 * Update shortcut given body.
 */
export const updateShortcutMutation = (
  options?: Partial<Options<UpdateShortcutData>>,
): UseMutationOptions<
  UpdateShortcutResponse,
  UpdateShortcutError,
  Options<UpdateShortcutData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateShortcutResponse,
    UpdateShortcutError,
    Options<UpdateShortcutData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateShortcut({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteItemsByIdThumbnailsMutation = (
  options?: Partial<Options<DeleteItemsByIdThumbnailsData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<DeleteItemsByIdThumbnailsData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<DeleteItemsByIdThumbnailsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteItemsByIdThumbnails({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const postItemsByIdThumbnailsQueryKey = (
  options: Options<PostItemsByIdThumbnailsData>,
) => createQueryKey('postItemsByIdThumbnails', options);

export const postItemsByIdThumbnailsOptions = (
  options: Options<PostItemsByIdThumbnailsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postItemsByIdThumbnails({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: postItemsByIdThumbnailsQueryKey(options),
  });
};

export const postItemsByIdThumbnailsMutation = (
  options?: Partial<Options<PostItemsByIdThumbnailsData>>,
): UseMutationOptions<
  PostItemsByIdThumbnailsResponse,
  PostItemsByIdThumbnailsError,
  Options<PostItemsByIdThumbnailsData>
> => {
  const mutationOptions: UseMutationOptions<
    PostItemsByIdThumbnailsResponse,
    PostItemsByIdThumbnailsError,
    Options<PostItemsByIdThumbnailsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postItemsByIdThumbnails({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const downloadItemThumbnailQueryKey = (
  options: Options<DownloadItemThumbnailData>,
) => createQueryKey('downloadItemThumbnail', options);

/**
 * Get an item's thumbnail
 * Get an item's thumbnail at given size. The return value is null if the item did not previously have a thumbnail.
 */
export const downloadItemThumbnailOptions = (
  options: Options<DownloadItemThumbnailData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await downloadItemThumbnail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: downloadItemThumbnailQueryKey(options),
  });
};

export const uploadFileQueryKey = (options?: Options<UploadFileData>) =>
  createQueryKey('uploadFile', options);

/**
 * Upload files
 * Upload files to create corresponding items.
 */
export const uploadFileOptions = (options?: Options<UploadFileData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadFile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadFileQueryKey(options),
  });
};

/**
 * Upload files
 * Upload files to create corresponding items.
 */
export const uploadFileMutation = (
  options?: Partial<Options<UploadFileData>>,
): UseMutationOptions<
  UploadFileResponse,
  UploadFileError,
  Options<UploadFileData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadFileResponse,
    UploadFileError,
    Options<UploadFileData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await uploadFile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUrlQueryKey = (options: Options<GetUrlData>) =>
  createQueryKey('getUrl', options);

/**
 * Get file URL
 * Get file URL.
 */
export const getUrlOptions = (options: Options<GetUrlData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUrl({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUrlQueryKey(options),
  });
};

/**
 * Update file
 * Update file.
 */
export const updateFileMutation = (
  options?: Partial<Options<UpdateFileData>>,
): UseMutationOptions<unknown, UpdateFileError, Options<UpdateFileData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UpdateFileError,
    Options<UpdateFileData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete visibility of item
 * Delete visibility of item with given type.
 */
export const deleteVisibilityMutation = (
  options?: Partial<Options<DeleteVisibilityData>>,
): UseMutationOptions<
  DeleteVisibilityResponse,
  DeleteVisibilityError,
  Options<DeleteVisibilityData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteVisibilityResponse,
    DeleteVisibilityError,
    Options<DeleteVisibilityData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteVisibility({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createVisibilityQueryKey = (
  options: Options<CreateVisibilityData>,
) => createQueryKey('createVisibility', options);

/**
 * Create visibility on item
 * Create visibility on item with given visibility that will apply on itself and its descendants.
 */
export const createVisibilityOptions = (
  options: Options<CreateVisibilityData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createVisibility({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createVisibilityQueryKey(options),
  });
};

/**
 * Create visibility on item
 * Create visibility on item with given visibility that will apply on itself and its descendants.
 */
export const createVisibilityMutation = (
  options?: Partial<Options<CreateVisibilityData>>,
): UseMutationOptions<
  CreateVisibilityResponse,
  CreateVisibilityError,
  Options<CreateVisibilityData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateVisibilityResponse,
    CreateVisibilityError,
    Options<CreateVisibilityData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createVisibility({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createFolderQueryKey = (options: Options<CreateFolderData>) =>
  createQueryKey('createFolder', options);

/**
 * Create folder
 * Create folder.
 */
export const createFolderOptions = (options: Options<CreateFolderData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFolder({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFolderQueryKey(options),
  });
};

/**
 * Create folder
 * Create folder.
 */
export const createFolderMutation = (
  options?: Partial<Options<CreateFolderData>>,
): UseMutationOptions<
  CreateFolderResponse,
  CreateFolderError,
  Options<CreateFolderData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFolderResponse,
    CreateFolderError,
    Options<CreateFolderData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFolder({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update folder
 * Update folder given body.
 */
export const updateFolderMutation = (
  options?: Partial<Options<UpdateFolderData>>,
): UseMutationOptions<
  UpdateFolderResponse,
  UpdateFolderError,
  Options<UpdateFolderData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFolderResponse,
    UpdateFolderError,
    Options<UpdateFolderData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFolder({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createFolderWithThumbnailQueryKey = (
  options?: Options<CreateFolderWithThumbnailData>,
) => createQueryKey('createFolderWithThumbnail', options);

/**
 * Create a folder with a thumbnail
 * Create a folder with a thumbnail. The data is sent using a form-data.
 */
export const createFolderWithThumbnailOptions = (
  options?: Options<CreateFolderWithThumbnailData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFolderWithThumbnail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFolderWithThumbnailQueryKey(options),
  });
};

/**
 * Create a folder with a thumbnail
 * Create a folder with a thumbnail. The data is sent using a form-data.
 */
export const createFolderWithThumbnailMutation = (
  options?: Partial<Options<CreateFolderWithThumbnailData>>,
): UseMutationOptions<
  CreateFolderWithThumbnailResponse,
  CreateFolderWithThumbnailError,
  Options<CreateFolderWithThumbnailData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFolderWithThumbnailResponse,
    CreateFolderWithThumbnailError,
    Options<CreateFolderWithThumbnailData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFolderWithThumbnail({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createAppQueryKey = (options: Options<CreateAppData>) =>
  createQueryKey('createApp', options);

/**
 * Create app
 * Create app.
 */
export const createAppOptions = (options: Options<CreateAppData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createApp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAppQueryKey(options),
  });
};

/**
 * Create app
 * Create app.
 */
export const createAppMutation = (
  options?: Partial<Options<CreateAppData>>,
): UseMutationOptions<
  CreateAppResponse,
  CreateAppError,
  Options<CreateAppData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAppResponse,
    CreateAppError,
    Options<CreateAppData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createApp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update app
 * Update app given body.
 */
export const updateAppMutation = (
  options?: Partial<Options<UpdateAppData>>,
): UseMutationOptions<
  UpdateAppResponse,
  UpdateAppError,
  Options<UpdateAppData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAppResponse,
    UpdateAppError,
    Options<UpdateAppData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateApp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete alias
 * Delete short link's alias.
 */
export const deleteAliasMutation = (
  options?: Partial<Options<DeleteAliasData>>,
): UseMutationOptions<
  DeleteAliasResponse,
  DeleteAliasError,
  Options<DeleteAliasData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAliasResponse,
    DeleteAliasError,
    Options<DeleteAliasData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAlias({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getShortLinkRedirectionQueryKey = (
  options: Options<GetShortLinkRedirectionData>,
) => createQueryKey('getShortLinkRedirection', options);

/**
 * Get redirection for short link
 * Get redirection for given short link.
 */
export const getShortLinkRedirectionOptions = (
  options: Options<GetShortLinkRedirectionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getShortLinkRedirection({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getShortLinkRedirectionQueryKey(options),
  });
};

/**
 * Update short link
 * Update the alias of the short link.
 */
export const updateShortLinkMutation = (
  options?: Partial<Options<UpdateShortLinkData>>,
): UseMutationOptions<
  UpdateShortLinkResponse,
  UpdateShortLinkError,
  Options<UpdateShortLinkData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateShortLinkResponse,
    UpdateShortLinkError,
    Options<UpdateShortLinkData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateShortLink({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getShortLinkAvailabilityQueryKey = (
  options: Options<GetShortLinkAvailabilityData>,
) => createQueryKey('getShortLinkAvailability', options);

/**
 * Get whether an alias is available
 * Get whether an alias is available.
 */
export const getShortLinkAvailabilityOptions = (
  options: Options<GetShortLinkAvailabilityData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getShortLinkAvailability({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getShortLinkAvailabilityQueryKey(options),
  });
};

export const getShortLinksForItemQueryKey = (
  options: Options<GetShortLinksForItemData>,
) => createQueryKey('getShortLinksForItem', options);

/**
 * Get all short links for item
 * Get all short links created for an item. The response could be an empty object or a key-value with at least one platform and the alias.
 */
export const getShortLinksForItemOptions = (
  options: Options<GetShortLinksForItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getShortLinksForItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getShortLinksForItemQueryKey(options),
  });
};

export const createShortLinkQueryKey = (
  options: Options<CreateShortLinkData>,
) => createQueryKey('createShortLink', options);

/**
 * Create short link for item
 * Create short link for item.
 */
export const createShortLinkOptions = (
  options: Options<CreateShortLinkData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createShortLink({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createShortLinkQueryKey(options),
  });
};

/**
 * Create short link for item
 * Create short link for item.
 */
export const createShortLinkMutation = (
  options?: Partial<Options<CreateShortLinkData>>,
): UseMutationOptions<
  CreateShortLinkResponse,
  CreateShortLinkError,
  Options<CreateShortLinkData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateShortLinkResponse,
    CreateShortLinkError,
    Options<CreateShortLinkData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createShortLink({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getItemsPublicationByItemIdStatusQueryKey = (
  options: Options<GetItemsPublicationByItemIdStatusData>,
) => createQueryKey('getItemsPublicationByItemIdStatus', options);

export const getItemsPublicationByItemIdStatusOptions = (
  options: Options<GetItemsPublicationByItemIdStatusData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemsPublicationByItemIdStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemsPublicationByItemIdStatusQueryKey(options),
  });
};

export const getItemsH5pAssetsIntegrationHtmlQueryKey = (
  options?: Options<GetItemsH5pAssetsIntegrationHtmlData>,
) => createQueryKey('getItemsH5pAssetsIntegrationHtml', options);

export const getItemsH5pAssetsIntegrationHtmlOptions = (
  options?: Options<GetItemsH5pAssetsIntegrationHtmlData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemsH5pAssetsIntegrationHtml({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemsH5pAssetsIntegrationHtmlQueryKey(options),
  });
};

export const importH5PQueryKey = (options?: Options<ImportH5pData>) =>
  createQueryKey('importH5P', options);

/**
 * Import H5P file
 * Import H5P file and create corresponding item.
 */
export const importH5POptions = (options?: Options<ImportH5pData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await importH5P({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: importH5PQueryKey(options),
  });
};

/**
 * Import H5P file
 * Import H5P file and create corresponding item.
 */
export const importH5PMutation = (
  options?: Partial<Options<ImportH5pData>>,
): UseMutationOptions<
  ImportH5pResponse,
  ImportH5pError,
  Options<ImportH5pData>
> => {
  const mutationOptions: UseMutationOptions<
    ImportH5pResponse,
    ImportH5pError,
    Options<ImportH5pData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await importH5P({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createEtherpadQueryKey = (options: Options<CreateEtherpadData>) =>
  createQueryKey('createEtherpad', options);

/**
 * Create etherpad
 * Create an etherpad item.
 */
export const createEtherpadOptions = (options: Options<CreateEtherpadData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createEtherpad({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createEtherpadQueryKey(options),
  });
};

/**
 * Create etherpad
 * Create an etherpad item.
 */
export const createEtherpadMutation = (
  options?: Partial<Options<CreateEtherpadData>>,
): UseMutationOptions<
  CreateEtherpadResponse,
  CreateEtherpadError,
  Options<CreateEtherpadData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateEtherpadResponse,
    CreateEtherpadError,
    Options<CreateEtherpadData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createEtherpad({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update etherpad
 * Update etherpad properties, including permission of readers.
 */
export const updateEtherpadMutation = (
  options?: Partial<Options<UpdateEtherpadData>>,
): UseMutationOptions<
  UpdateEtherpadResponse,
  UpdateEtherpadError,
  Options<UpdateEtherpadData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateEtherpadResponse,
    UpdateEtherpadError,
    Options<UpdateEtherpadData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateEtherpad({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getEtherpadFromItemQueryKey = (
  options: Options<GetEtherpadFromItemData>,
) => createQueryKey('getEtherpadFromItem', options);

/**
 * Get etherpad information
 * Get etherpad information from item id
 */
export const getEtherpadFromItemOptions = (
  options: Options<GetEtherpadFromItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEtherpadFromItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEtherpadFromItemQueryKey(options),
  });
};

export const importZipQueryKey = (options?: Options<ImportZipData>) =>
  createQueryKey('importZip', options);

/**
 * Import ZIP content
 * Import and extract the content of a ZIP, creating the corresponding structure and items.
 */
export const importZipOptions = (options?: Options<ImportZipData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await importZip({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: importZipQueryKey(options),
  });
};

/**
 * Import ZIP content
 * Import and extract the content of a ZIP, creating the corresponding structure and items.
 */
export const importZipMutation = (
  options?: Partial<Options<ImportZipData>>,
): UseMutationOptions<unknown, ImportZipError, Options<ImportZipData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ImportZipError,
    Options<ImportZipData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await importZip({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const downloadFileQueryKey = (options: Options<DownloadFileData>) =>
  createQueryKey('downloadFile', options);

/**
 * Download non-folder content
 * Download non-folder content. Return raw file for single item.
 */
export const downloadFileOptions = (options: Options<DownloadFileData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await downloadFile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: downloadFileQueryKey(options),
  });
};

/**
 * Download non-folder content
 * Download non-folder content. Return raw file for single item.
 */
export const downloadFileMutation = (
  options?: Partial<Options<DownloadFileData>>,
): UseMutationOptions<
  unknown,
  DownloadFileError,
  Options<DownloadFileData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DownloadFileError,
    Options<DownloadFileData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await downloadFile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const exportZipQueryKey = (options: Options<ExportZipData>) =>
  createQueryKey('exportZip', options);

/**
 * Export folder content as zip archive
 * Export the folder's content as a ZIP archive. The user will receive an email with a link to download the ZIP archive.
 */
export const exportZipOptions = (options: Options<ExportZipData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await exportZip({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: exportZipQueryKey(options),
  });
};

/**
 * Export folder content as zip archive
 * Export the folder's content as a ZIP archive. The user will receive an email with a link to download the ZIP archive.
 */
export const exportZipMutation = (
  options?: Partial<Options<ExportZipData>>,
): UseMutationOptions<unknown, ExportZipError, Options<ExportZipData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ExportZipError,
    Options<ExportZipData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await exportZip({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const graaspZipExportQueryKey = (
  options: Options<GraaspZipExportData>,
) => createQueryKey('graaspZipExport', options);

/**
 * Export content
 * Export content. Return raw file for single item, or a ZIP with structure and items for a folder.
 */
export const graaspZipExportOptions = (
  options: Options<GraaspZipExportData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await graaspZipExport({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: graaspZipExportQueryKey(options),
  });
};

/**
 * Export content
 * Export content. Return raw file for single item, or a ZIP with structure and items for a folder.
 */
export const graaspZipExportMutation = (
  options?: Partial<Options<GraaspZipExportData>>,
): UseMutationOptions<
  unknown,
  GraaspZipExportError,
  Options<GraaspZipExportData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    GraaspZipExportError,
    Options<GraaspZipExportData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await graaspZipExport({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLinkMetadataQueryKey = (
  options: Options<GetLinkMetadataData>,
) => createQueryKey('getLinkMetadata', options);

/**
 * Get metadata information from iframely for given url
 * Get metadata information from iframely for given url.
 */
export const getLinkMetadataOptions = (
  options: Options<GetLinkMetadataData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLinkMetadata({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLinkMetadataQueryKey(options),
  });
};

export const createLinkQueryKey = (options: Options<CreateLinkData>) =>
  createQueryKey('createLink', options);

/**
 * Create link
 * Create link.
 */
export const createLinkOptions = (options: Options<CreateLinkData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createLink({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createLinkQueryKey(options),
  });
};

/**
 * Create link
 * Create link.
 */
export const createLinkMutation = (
  options?: Partial<Options<CreateLinkData>>,
): UseMutationOptions<
  CreateLinkResponse,
  CreateLinkError,
  Options<CreateLinkData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateLinkResponse,
    CreateLinkError,
    Options<CreateLinkData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createLink({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update link
 * Update link given body.
 */
export const updateLinkMutation = (
  options?: Partial<Options<UpdateLinkData>>,
): UseMutationOptions<
  UpdateLinkResponse,
  UpdateLinkError,
  Options<UpdateLinkData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateLinkResponse,
    UpdateLinkError,
    Options<UpdateLinkData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateLink({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createDocumentQueryKey = (options: Options<CreateDocumentData>) =>
  createQueryKey('createDocument', options);

/**
 * Create document
 * Create document with given payload. The content will be sanitized.
 */
export const createDocumentOptions = (options: Options<CreateDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createDocumentQueryKey(options),
  });
};

/**
 * Create document
 * Create document with given payload. The content will be sanitized.
 */
export const createDocumentMutation = (
  options?: Partial<Options<CreateDocumentData>>,
): UseMutationOptions<
  CreateDocumentResponse,
  CreateDocumentError,
  Options<CreateDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateDocumentResponse,
    CreateDocumentError,
    Options<CreateDocumentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update document
 * Update document given payload. The content will be sanitized.
 */
export const updateDocumentMutation = (
  options?: Partial<Options<UpdateDocumentData>>,
): UseMutationOptions<
  UpdateDocumentResponse,
  UpdateDocumentError,
  Options<UpdateDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateDocumentResponse,
    UpdateDocumentError,
    Options<UpdateDocumentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInvitationByIdQueryKey = (
  options: Options<GetInvitationByIdData>,
) => createQueryKey('getInvitationById', options);

/**
 * Get invitation
 * Get invitation by id
 */
export const getInvitationByIdOptions = (
  options: Options<GetInvitationByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInvitationById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInvitationByIdQueryKey(options),
  });
};

export const createInvitationQueryKey = (
  options: Options<CreateInvitationData>,
) => createQueryKey('createInvitation', options);

/**
 * Invite user by email to access an item
 * Invite non-registered user with their email to access given item.
 */
export const createInvitationOptions = (
  options: Options<CreateInvitationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createInvitationQueryKey(options),
  });
};

/**
 * Invite user by email to access an item
 * Invite non-registered user with their email to access given item.
 */
export const createInvitationMutation = (
  options?: Partial<Options<CreateInvitationData>>,
): UseMutationOptions<
  CreateInvitationResponse,
  CreateInvitationError,
  Options<CreateInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateInvitationResponse,
    CreateInvitationError,
    Options<CreateInvitationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInvitationForItemQueryKey = (
  options: Options<GetInvitationForItemData>,
) => createQueryKey('getInvitationForItem', options);

/**
 * Get invitations for a given item
 * Get invitation for a given item
 */
export const getInvitationForItemOptions = (
  options: Options<GetInvitationForItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInvitationForItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInvitationForItemQueryKey(options),
  });
};

/**
 * Delete invitation
 * Delete invitation
 */
export const deleteInvitationMutation = (
  options?: Partial<Options<DeleteInvitationData>>,
): UseMutationOptions<
  DeleteInvitationResponse,
  DeleteInvitationError,
  Options<DeleteInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteInvitationResponse,
    DeleteInvitationError,
    Options<DeleteInvitationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update invitation
 * Update invitation's name or permission
 */
export const updateInvitationMutation = (
  options?: Partial<Options<UpdateInvitationData>>,
): UseMutationOptions<
  UpdateInvitationResponse,
  UpdateInvitationError,
  Options<UpdateInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInvitationResponse,
    UpdateInvitationError,
    Options<UpdateInvitationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const sendInvitationQueryKey = (options: Options<SendInvitationData>) =>
  createQueryKey('sendInvitation', options);

/**
 * Send invitation
 * Send invitation
 */
export const sendInvitationOptions = (options: Options<SendInvitationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await sendInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: sendInvitationQueryKey(options),
  });
};

/**
 * Send invitation
 * Send invitation
 */
export const sendInvitationMutation = (
  options?: Partial<Options<SendInvitationData>>,
): UseMutationOptions<
  SendInvitationResponse,
  SendInvitationError,
  Options<SendInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    SendInvitationResponse,
    SendInvitationError,
    Options<SendInvitationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await sendInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const inviteFromCsvWithTemplateQueryKey = (
  options: Options<InviteFromCsvWithTemplateData>,
) => createQueryKey('inviteFromCsvWithTemplate', options);

/**
 * Invite users from CSV file in groups given a template
 * Invite users by groups from CSV. This will create groups of users having access to corresponding resources from a given template.
 */
export const inviteFromCsvWithTemplateOptions = (
  options: Options<InviteFromCsvWithTemplateData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await inviteFromCsvWithTemplate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: inviteFromCsvWithTemplateQueryKey(options),
  });
};

/**
 * Invite users from CSV file in groups given a template
 * Invite users by groups from CSV. This will create groups of users having access to corresponding resources from a given template.
 */
export const inviteFromCsvWithTemplateMutation = (
  options?: Partial<Options<InviteFromCsvWithTemplateData>>,
): UseMutationOptions<
  InviteFromCsvWithTemplateResponse,
  InviteFromCsvWithTemplateError,
  Options<InviteFromCsvWithTemplateData>
> => {
  const mutationOptions: UseMutationOptions<
    InviteFromCsvWithTemplateResponse,
    InviteFromCsvWithTemplateError,
    Options<InviteFromCsvWithTemplateData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await inviteFromCsvWithTemplate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const inviteFromCsvQueryKey = (options: Options<InviteFromCsvData>) =>
  createQueryKey('inviteFromCsv', options);

/**
 * Invite users from CSV file
 * Invite users from CSV file, given their email, optional name and permission level.
 */
export const inviteFromCsvOptions = (options: Options<InviteFromCsvData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await inviteFromCsv({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: inviteFromCsvQueryKey(options),
  });
};

/**
 * Invite users from CSV file
 * Invite users from CSV file, given their email, optional name and permission level.
 */
export const inviteFromCsvMutation = (
  options?: Partial<Options<InviteFromCsvData>>,
): UseMutationOptions<
  InviteFromCsvResponse,
  InviteFromCsvError,
  Options<InviteFromCsvData>
> => {
  const mutationOptions: UseMutationOptions<
    InviteFromCsvResponse,
    InviteFromCsvError,
    Options<InviteFromCsvData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await inviteFromCsv({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const enrollQueryKey = (options: Options<EnrollData>) =>
  createQueryKey('enroll', options);

/**
 * Create an item membership for the logged in user if there is an Item Login
 * Create an item membership on the item with the given ID for the logged in user.
 * The item needs to be associated with an Item Login.
 */
export const enrollOptions = (options: Options<EnrollData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await enroll({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: enrollQueryKey(options),
  });
};

/**
 * Create an item membership for the logged in user if there is an Item Login
 * Create an item membership on the item with the given ID for the logged in user.
 * The item needs to be associated with an Item Login.
 */
export const enrollMutation = (
  options?: Partial<Options<EnrollData>>,
): UseMutationOptions<EnrollResponse, DefaultError, Options<EnrollData>> => {
  const mutationOptions: UseMutationOptions<
    EnrollResponse,
    DefaultError,
    Options<EnrollData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await enroll({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFlagTypesQueryKey = (options?: Options<GetFlagTypesData>) =>
  createQueryKey('getFlagTypes', options);

/**
 * Get flag types
 * Get available flag types.
 */
export const getFlagTypesOptions = (options?: Options<GetFlagTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFlagTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFlagTypesQueryKey(options),
  });
};

export const createItemFlagQueryKey = (options: Options<CreateItemFlagData>) =>
  createQueryKey('createItemFlag', options);

/**
 * Flag item
 * Flag item with given type.
 */
export const createItemFlagOptions = (options: Options<CreateItemFlagData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createItemFlag({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createItemFlagQueryKey(options),
  });
};

/**
 * Flag item
 * Flag item with given type.
 */
export const createItemFlagMutation = (
  options?: Partial<Options<CreateItemFlagData>>,
): UseMutationOptions<
  CreateItemFlagResponse,
  CreateItemFlagError,
  Options<CreateItemFlagData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateItemFlagResponse,
    CreateItemFlagError,
    Options<CreateItemFlagData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createItemFlag({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOwnRecycledItemsQueryKey = (
  options: Options<GetOwnRecycledItemsData>,
) => createQueryKey('getOwnRecycledItems', options);

/**
 * Get own recycled items
 * Get own recycled items.
 */
export const getOwnRecycledItemsOptions = (
  options: Options<GetOwnRecycledItemsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnRecycledItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnRecycledItemsQueryKey(options),
  });
};

export const getOwnRecycledItemsInfiniteQueryKey = (
  options: Options<GetOwnRecycledItemsData>,
): QueryKey<Options<GetOwnRecycledItemsData>> =>
  createQueryKey('getOwnRecycledItems', options, true);

/**
 * Get own recycled items
 * Get own recycled items.
 */
export const getOwnRecycledItemsInfiniteOptions = (
  options: Options<GetOwnRecycledItemsData>,
) => {
  return infiniteQueryOptions<
    GetOwnRecycledItemsResponse,
    GetOwnRecycledItemsError,
    InfiniteData<GetOwnRecycledItemsResponse>,
    QueryKey<Options<GetOwnRecycledItemsData>>,
    | number
    | Pick<
        QueryKey<Options<GetOwnRecycledItemsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetOwnRecycledItemsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getOwnRecycledItems({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getOwnRecycledItemsInfiniteQueryKey(options),
    },
  );
};

export const recycleManyItemsQueryKey = (
  options: Options<RecycleManyItemsData>,
) => createQueryKey('recycleManyItems', options);

/**
 * Recycle many items
 * Recycle many items. This will create as many recycled item data.
 */
export const recycleManyItemsOptions = (
  options: Options<RecycleManyItemsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await recycleManyItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: recycleManyItemsQueryKey(options),
  });
};

/**
 * Recycle many items
 * Recycle many items. This will create as many recycled item data.
 */
export const recycleManyItemsMutation = (
  options?: Partial<Options<RecycleManyItemsData>>,
): UseMutationOptions<
  RecycleManyItemsResponse,
  RecycleManyItemsError,
  Options<RecycleManyItemsData>
> => {
  const mutationOptions: UseMutationOptions<
    RecycleManyItemsResponse,
    RecycleManyItemsError,
    Options<RecycleManyItemsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await recycleManyItems({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const restoreManyItemsQueryKey = (
  options: Options<RestoreManyItemsData>,
) => createQueryKey('restoreManyItems', options);

/**
 * Restore many items
 * Restore many items. This will delete as many recycled item data.
 */
export const restoreManyItemsOptions = (
  options: Options<RestoreManyItemsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await restoreManyItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: restoreManyItemsQueryKey(options),
  });
};

/**
 * Restore many items
 * Restore many items. This will delete as many recycled item data.
 */
export const restoreManyItemsMutation = (
  options?: Partial<Options<RestoreManyItemsData>>,
): UseMutationOptions<
  RestoreManyItemsResponse,
  RestoreManyItemsError,
  Options<RestoreManyItemsData>
> => {
  const mutationOptions: UseMutationOptions<
    RestoreManyItemsResponse,
    RestoreManyItemsError,
    Options<RestoreManyItemsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await restoreManyItems({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLatestItemValidationGroupQueryKey = (
  options: Options<GetLatestItemValidationGroupData>,
) => createQueryKey('getLatestItemValidationGroup', options);

/**
 * Get latest validation information.
 * Get latest validation information. Returns null if no validation has been performed before.
 */
export const getLatestItemValidationGroupOptions = (
  options: Options<GetLatestItemValidationGroupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLatestItemValidationGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLatestItemValidationGroupQueryKey(options),
  });
};

export const validateItemQueryKey = (options: Options<ValidateItemData>) =>
  createQueryKey('validateItem', options);

/**
 * Validate item
 * Validate item's tree against many processes, such as nudity detection.
 */
export const validateItemOptions = (options: Options<ValidateItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await validateItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: validateItemQueryKey(options),
  });
};

/**
 * Validate item
 * Validate item's tree against many processes, such as nudity detection.
 */
export const validateItemMutation = (
  options?: Partial<Options<ValidateItemData>>,
): UseMutationOptions<
  ValidateItemResponse,
  ValidateItemError,
  Options<ValidateItemData>
> => {
  const mutationOptions: UseMutationOptions<
    ValidateItemResponse,
    ValidateItemError,
    Options<ValidateItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await validateItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLikesForCurrentMemberQueryKey = (
  options?: Options<GetLikesForCurrentMemberData>,
) => createQueryKey('getLikesForCurrentMember', options);

/**
 * Get likes for current member
 * Get likes for current member. Item property is a packed item.
 */
export const getLikesForCurrentMemberOptions = (
  options?: Options<GetLikesForCurrentMemberData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLikesForCurrentMember({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLikesForCurrentMemberQueryKey(options),
  });
};

export const getLikesForItemQueryKey = (
  options: Options<GetLikesForItemData>,
) => createQueryKey('getLikesForItem', options);

/**
 * Get likes for item
 * Get likes for item.
 */
export const getLikesForItemOptions = (
  options: Options<GetLikesForItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLikesForItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLikesForItemQueryKey(options),
  });
};

/**
 * Unlike item
 * Unlike item.
 */
export const deleteItemLikeMutation = (
  options?: Partial<Options<DeleteItemLikeData>>,
): UseMutationOptions<
  DeleteItemLikeResponse,
  DeleteItemLikeError,
  Options<DeleteItemLikeData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteItemLikeResponse,
    DeleteItemLikeError,
    Options<DeleteItemLikeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteItemLike({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createItemLikeQueryKey = (options: Options<CreateItemLikeData>) =>
  createQueryKey('createItemLike', options);

/**
 * Like item
 * Like item.
 */
export const createItemLikeOptions = (options: Options<CreateItemLikeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createItemLike({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createItemLikeQueryKey(options),
  });
};

/**
 * Like item
 * Like item.
 */
export const createItemLikeMutation = (
  options?: Partial<Options<CreateItemLikeData>>,
): UseMutationOptions<
  CreateItemLikeResponse,
  CreateItemLikeError,
  Options<CreateItemLikeData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateItemLikeResponse,
    CreateItemLikeError,
    Options<CreateItemLikeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createItemLike({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Clear all mentions for current user
 * Clear all mentions for current user.
 */
export const clearAllMentionsMutation = (
  options?: Partial<Options<ClearAllMentionsData>>,
): UseMutationOptions<
  ClearAllMentionsResponse,
  ClearAllMentionsError,
  Options<ClearAllMentionsData>
> => {
  const mutationOptions: UseMutationOptions<
    ClearAllMentionsResponse,
    ClearAllMentionsError,
    Options<ClearAllMentionsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await clearAllMentions({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOwnMentionsQueryKey = (options?: Options<GetOwnMentionsData>) =>
  createQueryKey('getOwnMentions', options);

/**
 * Get mentions for current user
 * Get mentions for current user.
 */
export const getOwnMentionsOptions = (
  options?: Options<GetOwnMentionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnMentions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnMentionsQueryKey(options),
  });
};

/**
 * Delete mention
 * Delete mention.
 */
export const deleteMentionMutation = (
  options?: Partial<Options<DeleteMentionData>>,
): UseMutationOptions<
  DeleteMentionResponse,
  DeleteMentionError,
  Options<DeleteMentionData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteMentionResponse,
    DeleteMentionError,
    Options<DeleteMentionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteMention({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Patch mention
 * Patch mention's status.
 */
export const patchMentionMutation = (
  options?: Partial<Options<PatchMentionData>>,
): UseMutationOptions<
  PatchMentionResponse,
  PatchMentionError,
  Options<PatchMentionData>
> => {
  const mutationOptions: UseMutationOptions<
    PatchMentionResponse,
    PatchMentionError,
    Options<PatchMentionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await patchMention({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Clear messages of chat
 * Clear messages of chat for given item.
 */
export const clearChatMessageMutation = (
  options?: Partial<Options<ClearChatMessageData>>,
): UseMutationOptions<
  ClearChatMessageResponse,
  ClearChatMessageError,
  Options<ClearChatMessageData>
> => {
  const mutationOptions: UseMutationOptions<
    ClearChatMessageResponse,
    ClearChatMessageError,
    Options<ClearChatMessageData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await clearChatMessage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getChatQueryKey = (options: Options<GetChatData>) =>
  createQueryKey('getChat', options);

/**
 * Get chat
 * Get chat object for given item.
 */
export const getChatOptions = (options: Options<GetChatData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getChat({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getChatQueryKey(options),
  });
};

export const createChatMessageQueryKey = (
  options: Options<CreateChatMessageData>,
) => createQueryKey('createChatMessage', options);

/**
 * Save message in chat
 * Save message in chat for given item.
 */
export const createChatMessageOptions = (
  options: Options<CreateChatMessageData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createChatMessage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createChatMessageQueryKey(options),
  });
};

/**
 * Save message in chat
 * Save message in chat for given item.
 */
export const createChatMessageMutation = (
  options?: Partial<Options<CreateChatMessageData>>,
): UseMutationOptions<
  CreateChatMessageResponse,
  CreateChatMessageError,
  Options<CreateChatMessageData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateChatMessageResponse,
    CreateChatMessageError,
    Options<CreateChatMessageData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createChatMessage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete message in chat
 * Delete message in chat for given item.
 */
export const deleteChatMessageMutation = (
  options?: Partial<Options<DeleteChatMessageData>>,
): UseMutationOptions<
  DeleteChatMessageResponse,
  DeleteChatMessageError,
  Options<DeleteChatMessageData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteChatMessageResponse,
    DeleteChatMessageError,
    Options<DeleteChatMessageData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteChatMessage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Edit message in chat
 * Edit message in chat for given item.
 */
export const patchChatMessageMutation = (
  options?: Partial<Options<PatchChatMessageData>>,
): UseMutationOptions<
  PatchChatMessageResponse,
  PatchChatMessageError,
  Options<PatchChatMessageData>
> => {
  const mutationOptions: UseMutationOptions<
    PatchChatMessageResponse,
    PatchChatMessageError,
    Options<PatchChatMessageData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await patchChatMessage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const postActionQueryKey = (options: Options<PostActionData>) =>
  createQueryKey('postAction', options);

/**
 * Save action for item
 * Save action for item with given type and extra.
 */
export const postActionOptions = (options: Options<PostActionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postAction({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: postActionQueryKey(options),
  });
};

/**
 * Save action for item
 * Save action for item with given type and extra.
 */
export const postActionMutation = (
  options?: Partial<Options<PostActionData>>,
): UseMutationOptions<
  PostActionResponse,
  PostActionError,
  Options<PostActionData>
> => {
  const mutationOptions: UseMutationOptions<
    PostActionResponse,
    PostActionError,
    Options<PostActionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postAction({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const exportActionsQueryKey = (options: Options<ExportActionsData>) =>
  createQueryKey('exportActions', options);

/**
 * Send request to export actions
 * Send request to export actions for given item. The user receives an email with a download link. The generated export is available for a week, and can be generated only once a day.
 */
export const exportActionsOptions = (options: Options<ExportActionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await exportActions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: exportActionsQueryKey(options),
  });
};

/**
 * Send request to export actions
 * Send request to export actions for given item. The user receives an email with a download link. The generated export is available for a week, and can be generated only once a day.
 */
export const exportActionsMutation = (
  options?: Partial<Options<ExportActionsData>>,
): UseMutationOptions<
  ExportActionsResponse,
  ExportActionsError,
  Options<ExportActionsData>
> => {
  const mutationOptions: UseMutationOptions<
    ExportActionsResponse,
    ExportActionsError,
    Options<ExportActionsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await exportActions({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getItemActionsByDayQueryKey = (
  options: Options<GetItemActionsByDayData>,
) => createQueryKey('getItemActionsByDay', options);

/**
 * Get actions for item and its descendants by day
 * Get sum of actions count per type generated by users for the given item and its descendants by day.
 */
export const getItemActionsByDayOptions = (
  options: Options<GetItemActionsByDayData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemActionsByDay({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemActionsByDayQueryKey(options),
  });
};

export const getItemActionsByHourQueryKey = (
  options: Options<GetItemActionsByHourData>,
) => createQueryKey('getItemActionsByHour', options);

/**
 * Get actions for item and its descendants by hour
 * Get sum of actions count per type generated by users for the given item and its descendants by hour.
 */
export const getItemActionsByHourOptions = (
  options: Options<GetItemActionsByHourData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemActionsByHour({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemActionsByHourQueryKey(options),
  });
};

export const getItemActionsByWeekdayQueryKey = (
  options: Options<GetItemActionsByWeekdayData>,
) => createQueryKey('getItemActionsByWeekday', options);

/**
 * Get actions for item and its descendants by weekday
 * Get sum of actions count per type generated by users for the given item and its descendants by weekday.
 */
export const getItemActionsByWeekdayOptions = (
  options: Options<GetItemActionsByWeekdayData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemActionsByWeekday({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemActionsByWeekdayQueryKey(options),
  });
};

/**
 * Remove a geolocation for an item
 * Remove a geolocation for an item.
 */
export const deleteGeolocationMutation = (
  options?: Partial<Options<DeleteGeolocationData>>,
): UseMutationOptions<
  DeleteGeolocationResponse,
  DeleteGeolocationError,
  Options<DeleteGeolocationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteGeolocationResponse,
    DeleteGeolocationError,
    Options<DeleteGeolocationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteGeolocation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getGeolocationByItemQueryKey = (
  options: Options<GetGeolocationByItemData>,
) => createQueryKey('getGeolocationByItem', options);

/**
 * Get the geolocation info of the given item
 * Get the geolocation info of the given item, alongside the complete information about the item.
 */
export const getGeolocationByItemOptions = (
  options: Options<GetGeolocationByItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGeolocationByItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGeolocationByItemQueryKey(options),
  });
};

/**
 * Set a geolocation on an item
 * Set a geolocation on an item.
 */
export const putGeolocationMutation = (
  options?: Partial<Options<PutGeolocationData>>,
): UseMutationOptions<
  PutGeolocationResponse,
  PutGeolocationError,
  Options<PutGeolocationData>
> => {
  const mutationOptions: UseMutationOptions<
    PutGeolocationResponse,
    PutGeolocationError,
    Options<PutGeolocationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await putGeolocation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getItemsInBoxQueryKey = (options: Options<GetItemsInBoxData>) =>
  createQueryKey('getItemsInBox', options);

/**
 * Get items within a box defined by geographic coordinates
 * Get accessible items within a box defined by geographic coordinates, within a parent if given.
 */
export const getItemsInBoxOptions = (options: Options<GetItemsInBoxData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItemsInBox({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemsInBoxQueryKey(options),
  });
};

export const geolocationReverseQueryKey = (
  options: Options<GeolocationReverseData>,
) => createQueryKey('geolocationReverse', options);

/**
 * Get address information of given geographic coordinates
 * Get address information of given geographic coordinates. This endpoint is using a third-party API.
 */
export const geolocationReverseOptions = (
  options: Options<GeolocationReverseData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await geolocationReverse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: geolocationReverseQueryKey(options),
  });
};

export const geolocationSearchQueryKey = (
  options: Options<GeolocationSearchData>,
) => createQueryKey('geolocationSearch', options);

/**
 * Get geographic information from a string
 * Get geographic information from a string. This endpoint is using a third-party API.
 */
export const geolocationSearchOptions = (
  options: Options<GeolocationSearchData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await geolocationSearch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: geolocationSearchQueryKey(options),
  });
};

export const getTagsForItemQueryKey = (options: Options<GetTagsForItemData>) =>
  createQueryKey('getTagsForItem', options);

/**
 * Get tags for item
 * Get tags for item.
 */
export const getTagsForItemOptions = (options: Options<GetTagsForItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTagsForItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTagsForItemQueryKey(options),
  });
};

export const createTagForItemQueryKey = (
  options: Options<CreateTagForItemData>,
) => createQueryKey('createTagForItem', options);

/**
 * Create tag for item
 * Create tag for the item. The tag will be associated with the given item. If the tag does not already exist in the common list of tags, it will be added and other users will see it in their suggestions.
 */
export const createTagForItemOptions = (
  options: Options<CreateTagForItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTagForItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTagForItemQueryKey(options),
  });
};

/**
 * Create tag for item
 * Create tag for the item. The tag will be associated with the given item. If the tag does not already exist in the common list of tags, it will be added and other users will see it in their suggestions.
 */
export const createTagForItemMutation = (
  options?: Partial<Options<CreateTagForItemData>>,
): UseMutationOptions<
  CreateTagForItemResponse,
  CreateTagForItemError,
  Options<CreateTagForItemData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTagForItemResponse,
    CreateTagForItemError,
    Options<CreateTagForItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createTagForItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete tag associated with item
 * Delete tag associated with item. It does not throw if the specified tag is not originally associated with the item.
 */
export const deleteTagForItemMutation = (
  options?: Partial<Options<DeleteTagForItemData>>,
): UseMutationOptions<
  DeleteTagForItemResponse,
  DeleteTagForItemError,
  Options<DeleteTagForItemData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTagForItemResponse,
    DeleteTagForItemError,
    Options<DeleteTagForItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteTagForItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete many items
 * Delete many items given their ids. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const deleteManyItemsMutation = (
  options?: Partial<Options<DeleteManyItemsData>>,
): UseMutationOptions<
  DeleteManyItemsResponse,
  DeleteManyItemsError,
  Options<DeleteManyItemsData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteManyItemsResponse,
    DeleteManyItemsError,
    Options<DeleteManyItemsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteManyItems({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createItemQueryKey = (options?: Options<CreateItemData>) =>
  createQueryKey('createItem', options);

/**
 * Create item
 * Create item, whose possible types are folder, app, document, embeddedLink, file, etherpad, h5p and shortcut.
 */
export const createItemOptions = (options?: Options<CreateItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createItemQueryKey(options),
  });
};

/**
 * Create item
 * Create item, whose possible types are folder, app, document, embeddedLink, file, etherpad, h5p and shortcut.
 */
export const createItemMutation = (
  options?: Partial<Options<CreateItemData>>,
): UseMutationOptions<
  CreateItemResponse,
  CreateItemError,
  Options<CreateItemData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateItemResponse,
    CreateItemError,
    Options<CreateItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getItemQueryKey = (options: Options<GetItemData>) =>
  createQueryKey('getItem', options);

/**
 * Get item
 * Get item by its id.
 */
export const getItemOptions = (options: Options<GetItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getItemQueryKey(options),
  });
};

/**
 * Update item
 * Update item given body.
 */
export const updateItemMutation = (
  options?: Partial<Options<UpdateItemData>>,
): UseMutationOptions<
  UpdateItemResponse,
  UpdateItemError,
  Options<UpdateItemData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateItemResponse,
    UpdateItemError,
    Options<UpdateItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAccessibleItemsQueryKey = (
  options: Options<GetAccessibleItemsData>,
) => createQueryKey('getAccessibleItems', options);

/**
 * Get accessible items
 * Get items the user has access to
 */
export const getAccessibleItemsOptions = (
  options: Options<GetAccessibleItemsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAccessibleItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAccessibleItemsQueryKey(options),
  });
};

export const getAccessibleItemsInfiniteQueryKey = (
  options: Options<GetAccessibleItemsData>,
): QueryKey<Options<GetAccessibleItemsData>> =>
  createQueryKey('getAccessibleItems', options, true);

/**
 * Get accessible items
 * Get items the user has access to
 */
export const getAccessibleItemsInfiniteOptions = (
  options: Options<GetAccessibleItemsData>,
) => {
  return infiniteQueryOptions<
    GetAccessibleItemsResponse,
    GetAccessibleItemsError,
    InfiniteData<GetAccessibleItemsResponse>,
    QueryKey<Options<GetAccessibleItemsData>>,
    | number
    | Pick<
        QueryKey<Options<GetAccessibleItemsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAccessibleItemsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAccessibleItems({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAccessibleItemsInfiniteQueryKey(options),
    },
  );
};

export const getChildrenQueryKey = (options: Options<GetChildrenData>) =>
  createQueryKey('getChildren', options);

/**
 * Get children of item
 * Get children of item given its id.
 */
export const getChildrenOptions = (options: Options<GetChildrenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getChildren({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getChildrenQueryKey(options),
  });
};

export const getDescendantItemsQueryKey = (
  options: Options<GetDescendantItemsData>,
) => createQueryKey('getDescendantItems', options);

/**
 * Get descendant items of item
 * Get descendant items of item given its id.
 */
export const getDescendantItemsOptions = (
  options: Options<GetDescendantItemsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDescendantItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDescendantItemsQueryKey(options),
  });
};

export const getParentItemsQueryKey = (options: Options<GetParentItemsData>) =>
  createQueryKey('getParentItems', options);

/**
 * Get parent items of item
 * Get parent items of item given its id.
 */
export const getParentItemsOptions = (options: Options<GetParentItemsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getParentItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getParentItemsQueryKey(options),
  });
};

/**
 * Reorder item
 * Reorder item within its parent given previous item id.
 */
export const reorderItemMutation = (
  options?: Partial<Options<ReorderItemData>>,
): UseMutationOptions<
  ReorderItemResponse,
  ReorderItemError,
  Options<ReorderItemData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderItemResponse,
    ReorderItemError,
    Options<ReorderItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await reorderItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const moveManyItemsQueryKey = (options: Options<MoveManyItemsData>) =>
  createQueryKey('moveManyItems', options);

/**
 * Move many items
 * Move many items given their ids to a parent target. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const moveManyItemsOptions = (options: Options<MoveManyItemsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await moveManyItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: moveManyItemsQueryKey(options),
  });
};

/**
 * Move many items
 * Move many items given their ids to a parent target. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const moveManyItemsMutation = (
  options?: Partial<Options<MoveManyItemsData>>,
): UseMutationOptions<
  MoveManyItemsResponse,
  MoveManyItemsError,
  Options<MoveManyItemsData>
> => {
  const mutationOptions: UseMutationOptions<
    MoveManyItemsResponse,
    MoveManyItemsError,
    Options<MoveManyItemsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await moveManyItems({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const copyManyItemsQueryKey = (options: Options<CopyManyItemsData>) =>
  createQueryKey('copyManyItems', options);

/**
 * Copy many items
 * Copy many items given their ids in a parent target. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const copyManyItemsOptions = (options: Options<CopyManyItemsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await copyManyItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: copyManyItemsQueryKey(options),
  });
};

/**
 * Copy many items
 * Copy many items given their ids in a parent target. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const copyManyItemsMutation = (
  options?: Partial<Options<CopyManyItemsData>>,
): UseMutationOptions<
  CopyManyItemsResponse,
  CopyManyItemsError,
  Options<CopyManyItemsData>
> => {
  const mutationOptions: UseMutationOptions<
    CopyManyItemsResponse,
    CopyManyItemsError,
    Options<CopyManyItemsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await copyManyItems({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createItemWithThumbnailQueryKey = (
  options?: Options<CreateItemWithThumbnailData>,
) => createQueryKey('createItemWithThumbnail', options);

/**
 * Create an item with a thumbnail
 * Create an item with a thumbnail. The data is sent using a form-data.
 */
export const createItemWithThumbnailOptions = (
  options?: Options<CreateItemWithThumbnailData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createItemWithThumbnail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createItemWithThumbnailQueryKey(options),
  });
};

/**
 * Create an item with a thumbnail
 * Create an item with a thumbnail. The data is sent using a form-data.
 */
export const createItemWithThumbnailMutation = (
  options?: Partial<Options<CreateItemWithThumbnailData>>,
): UseMutationOptions<
  CreateItemWithThumbnailResponse,
  CreateItemWithThumbnailError,
  Options<CreateItemWithThumbnailData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateItemWithThumbnailResponse,
    CreateItemWithThumbnailError,
    Options<CreateItemWithThumbnailData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createItemWithThumbnail({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCountForTagsQueryKey = (
  options: Options<GetCountForTagsData>,
) => createQueryKey('getCountForTags', options);

/**
 * Get count for tags
 * Get how many times a tag is associated with items, filtered by string search. It can be filtered by category. Get maximum the 10 most used tags.
 */
export const getCountForTagsOptions = (
  options: Options<GetCountForTagsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCountForTags({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCountForTagsQueryKey(options),
  });
};
